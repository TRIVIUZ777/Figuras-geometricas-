<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor Geom칠trico Interactivo</title>
    <!-- Carga de Tailwind CSS para un dise침o moderno y responsivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Definici칩n de la fuente y estilos base */
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            background-color: #f8fafc; /* Fondo gris muy claro */
        }
        /* Estilo para el canvas */
        #miCanvas {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border: 4px solid #334155; /* Gris oscuro para el borde */
            cursor: grab; 
            background-color: white;
            /* El canvas ser치 fluido para adaptarse al contenedor */
            width: 100%;
            max-width: 800px;
            height: 400px; 
            display: block;
        }
        /* Cursores para interacci칩n */
        .resizing { cursor: nwse-resize !important; }
        .rotating { cursor: move !important; }
        .dragging { cursor: grabbing !important; }
    </style>
</head>
<body class="p-4 sm:p-6 flex flex-col items-center justify-start">

    <header class="text-center mb-8">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-800 mb-2">
            游늻 Editor de Figuras Geom칠tricas
        </h1>
        <p class="text-gray-600 text-sm sm:text-base">
            Arrastra, redimensiona (punto azul) y rota (punto verde) tus figuras.
        </p>
    </header>

    <!-- Controles de Creaci칩n -->
    <div class="mb-6 flex flex-wrap justify-center gap-3 sm:gap-4 w-full max-w-lg">
        <button onclick="addShape('circle')" class="flex-1 min-w-[120px] bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 shadow-md transform hover:scale-[1.02]">
            A침adir C칤rculo
        </button>
        <button onclick="addShape('square')" class="flex-1 min-w-[120px] bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 shadow-md transform hover:scale-[1.02]">
            A침adir Cuadrado
        </button>
        <button onclick="addShape('triangle')" class="flex-1 min-w-[120px] bg-pink-600 hover:bg-pink-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 shadow-md transform hover:scale-[1.02]">
            A침adir Tri치ngulo
        </button>
        <button onclick="clearCanvas()" class="w-full sm:w-auto bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 shadow-md transform hover:scale-[1.02]">
            Limpiar Todo
        </button>
    </div>
    
    <!-- 츼rea de dibujo -->
    <div class="w-full flex justify-center">
        <canvas id="miCanvas" class="rounded-xl"></canvas>
    </div>

    <script>
        const canvas = document.getElementById("miCanvas");
        const ctx = canvas.getContext("2d");

        // --- Configuraci칩n Global ---
        const DEG_TO_RAD = Math.PI / 180;
        let shapes = []; 

        // --- Variables de Estado de Interacci칩n ---
        let isDragging = false;
        let isResizing = false;
        let isRotating = false;
        let selectedShape = null; 
        let dragOffsetX = 0;      
        let dragOffsetY = 0;      

        // Inicializar el tama침o del canvas de forma responsiva
        function resizeCanvas() {
            const containerWidth = canvas.parentElement.clientWidth;
            // Usar una relaci칩n de aspecto fija (e.g., 4:3) o un tama침o m치ximo
            canvas.width = Math.min(containerWidth, 800);
            canvas.height = 400; 
            drawShapes();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // Llamada inicial al cargar

        // -----------------------------------------------------
        // 1. DIBUJO Y REDIBUJADO
        // -----------------------------------------------------

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) { color += letters[Math.floor(Math.random() * 16)]; }
            return color;
        }
        
        /**
         * Dibuja una figura individual aplicando sus transformaciones.
         */
        function drawShape(shape) {
            ctx.save(); 

            // 1. Aplicar la rotaci칩n alrededor del centro (shape.x, shape.y)
            ctx.translate(shape.x, shape.y);
            ctx.rotate(shape.rotation);

            ctx.beginPath();
            ctx.fillStyle = shape.color;
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 2;

            // 2. Dibujar la figura centrada en (0, 0)
            if (shape.type === 'circle') {
                ctx.arc(0, 0, shape.radius, 0, 2 * Math.PI);
            } else if (shape.type === 'square') {
                ctx.rect(-shape.size / 2, -shape.size / 2, shape.size, shape.size);
            } else if (shape.type === 'triangle') {
                const h = shape.height;
                const b = shape.base;
                const topY = -(h * 2 / 3); // Posici칩n Y del v칠rtice superior (para centrar el centroide)
                
                ctx.moveTo(0, topY);
                ctx.lineTo(b / 2, topY + h);
                ctx.lineTo(-b / 2, topY + h);
                ctx.closePath();
            }

            ctx.fill();
            ctx.stroke();

            ctx.restore(); // 3. Restaurar el canvas al estado original

            // Dibujar controles si est치 seleccionado
            if (shape === selectedShape) {
                // Calcular la distancia de los controles fuera del l칤mite
                const majorAxis = shape.type === 'circle' ? shape.radius : 
                                  shape.type === 'square' ? shape.size * 0.707 : 
                                  Math.sqrt((shape.base / 2) ** 2 + shape.height ** 2) / 1.5; 
                
                const centerToControl = majorAxis + 15; // Distancia del centro

                // --- Control de Redimensionamiento (Azul) ---
                const resizeAngle = shape.rotation + 45 * DEG_TO_RAD; // 45 grados de rotaci칩n relativa
                const resizeX = shape.x + Math.cos(resizeAngle) * centerToControl;
                const resizeY = shape.y + Math.sin(resizeAngle) * centerToControl;

                ctx.beginPath();
                ctx.arc(resizeX, resizeY, 7, 0, 2 * Math.PI);
                ctx.fillStyle = '#2563eb'; // Azul oscuro
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.fill();
                ctx.stroke();

                // --- Control de Rotaci칩n (Verde) ---
                const rotateAngle = shape.rotation + 135 * DEG_TO_RAD; // 135 grados de rotaci칩n relativa
                const rotateX = shape.x + Math.cos(rotateAngle) * centerToControl;
                const rotateY = shape.y + Math.sin(rotateAngle) * centerToControl;
                
                ctx.beginPath();
                ctx.arc(rotateX, rotateY, 7, 0, 2 * Math.PI);
                ctx.fillStyle = '#16a34a'; // Verde oscuro
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.fill();
                ctx.stroke();
            }
        }

        /**
         * Limpia el canvas y redibuja todas las figuras.
         */
        function drawShapes() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            shapes.forEach(drawShape);
        }

        // -----------------------------------------------------
        // 2. CREACI칍N DE FIGURAS
        // -----------------------------------------------------

        function addShape(type) {
            const color = getRandomColor();
            // Posici칩n en el centro del canvas
            const x = canvas.width / 2;
            const y = canvas.height / 2;

            let newShape;

            if (type === 'circle') {
                newShape = { type: 'circle', x, y, radius: 40, color, rotation: 0 };
            } else if (type === 'square') {
                newShape = { type: 'square', x, y, size: 80, color, rotation: 0 };
            } else if (type === 'triangle') {
                newShape = { type: 'triangle', x, y, base: 80, height: 80, color, rotation: 0 };
            }

            shapes.unshift(newShape); // A침adir al principio para que se seleccione por defecto
            selectedShape = newShape;
            drawShapes();
        }

        function clearCanvas() {
            shapes = [];
            selectedShape = null;
            drawShapes();
        }

        // -----------------------------------------------------
        // 3. L칍GICA DE INTERACCI칍N
        // -----------------------------------------------------

        /**
         * Obtiene las coordenadas X/Y del puntero relativas al canvas.
         */
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX = e.clientX;
            let clientY = e.clientY;

            // Manejo de eventos t치ctiles
            if (e.touches && e.touches.length) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }

            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        /**
         * Aplica la rotaci칩n inversa al punto para chequear colisi칩n.
         */
        function getRotatedPoint(mx, my, shape) {
            const dx = mx - shape.x;
            const dy = my - shape.y;

            const cosA = Math.cos(-shape.rotation);
            const sinA = Math.sin(-shape.rotation);
            const rotatedX = dx * cosA - dy * sinA;
            const rotatedY = dx * sinA + dy * cosA;
            return { x: rotatedX, y: rotatedY };
        }

        /**
         * Verifica si un punto est치 dentro de la figura (compensando la rotaci칩n).
         */
        function isPointInShape(mx, my, shape) {
            const { x: rotatedX, y: rotatedY } = getRotatedPoint(mx, my, shape);

            if (shape.type === 'circle') {
                return (rotatedX * rotatedX + rotatedY * rotatedY < shape.radius * shape.radius);
            } else if (shape.type === 'square') {
                const halfSize = shape.size / 2;
                return (rotatedX > -halfSize && rotatedX < halfSize &&
                        rotatedY > -halfSize && rotatedY < halfSize);
            } else if (shape.type === 'triangle') {
                const halfBase = shape.base / 2;
                const h = shape.height;
                const topY = -(h * 2 / 3); 
                const bottomY = topY + h;

                // Chequeo simple de Bounding Box, suficiente para la interacci칩n
                return (rotatedX > -halfBase && rotatedX < halfBase &&
                        rotatedY > topY && rotatedY < bottomY);
            }
            return false;
        }

        /**
         * Verifica si un punto est치 en el control de redimensionamiento o rotaci칩n.
         */
        function isPointInControl(mx, my, shape, controlType) {
            const majorAxis = shape.type === 'circle' ? shape.radius : 
                              shape.type === 'square' ? shape.size * 0.707 : 
                              Math.sqrt((shape.base / 2) ** 2 + shape.height ** 2) / 1.5; 
            
            const centerToControl = majorAxis + 15;

            let angle;
            if (controlType === 'resize') {
                angle = shape.rotation + 45 * DEG_TO_RAD;
            } else if (controlType === 'rotate') {
                angle = shape.rotation + 135 * DEG_TO_RAD;
            } else {
                return false;
            }

            const ctrlX = shape.x + Math.cos(angle) * centerToControl;
            const ctrlY = shape.y + Math.sin(angle) * centerToControl;
            
            const dist = Math.sqrt(Math.pow(mx - ctrlX, 2) + Math.pow(my - ctrlY, 2));
            return dist < 10; // Margen de 10 p칤xeles
        }

        /**
         * Calcula el 치ngulo del vector (posici칩n del rat칩n - centro de la figura).
         */
        function getAngle(shape, pos) {
            const dx = pos.x - shape.x;
            const dy = pos.y - shape.y;
            return Math.atan2(dy, dx);
        }

        // --- MANEJADORES DE EVENTOS ---

        function handleMouseDown(e) {
            e.preventDefault();
            const pos = getMousePos(e);
            
            selectedShape = null;
            isDragging = false;
            isResizing = false;
            isRotating = false;

            // Recorrer las figuras para ver cu치l se ha clicado (de arriba a abajo)
            for (let i = 0; i < shapes.length; i++) {
                const shape = shapes[i];

                if (isPointInControl(pos.x, pos.y, shape, 'rotate')) {
                    selectedShape = shape;
                    isRotating = true;
                } else if (isPointInControl(pos.x, pos.y, shape, 'resize')) {
                    selectedShape = shape;
                    isResizing = true;
                } else if (isPointInShape(pos.x, pos.y, shape)) {
                    selectedShape = shape;
                    isDragging = true;
                    dragOffsetX = pos.x - shape.x;
                    dragOffsetY = pos.y - shape.y;
                }
                
                if (selectedShape) {
                    // Mover la figura seleccionada al frente
                    shapes.splice(i, 1);
                    shapes.unshift(selectedShape);
                    break;
                }
            }
            
            // Actualizar cursor y redibujar
            canvas.className = '';
            if (isDragging) { canvas.classList.add('dragging'); } 
            else if (isResizing) { canvas.classList.add('resizing'); } 
            else if (isRotating) { canvas.classList.add('rotating'); } 
            else { canvas.style.cursor = 'grab'; }
            
            drawShapes();
        }

        function handleMouseMove(e) {
            e.preventDefault();
            const pos = getMousePos(e);
            
            if (!selectedShape) {
                 // Previsualizaci칩n de cursor cuando no est치 activo un arrastre/rotaci칩n
                 let cursorFound = false;
                 for(const shape of shapes) {
                    if (isPointInControl(pos.x, pos.y, shape, 'resize')) {
                        canvas.style.cursor = 'nwse-resize';
                        cursorFound = true;
                        break;
                    } else if (isPointInControl(pos.x, pos.y, shape, 'rotate')) {
                        canvas.style.cursor = 'move';
                        cursorFound = true;
                        break;
                    } else if (isPointInShape(pos.x, pos.y, shape)) {
                        canvas.style.cursor = 'grab';
                        cursorFound = true;
                        break;
                    }
                 }
                 if (!cursorFound) { canvas.style.cursor = 'default'; }
                 return;
            }

            if (isRotating) {
                selectedShape.rotation = getAngle(selectedShape, pos);

            } else if (isResizing) {
                const { x: rotatedX, y: rotatedY } = getRotatedPoint(pos.x, pos.y, selectedShape);
                
                if (selectedShape.type === 'circle') {
                    const dx = pos.x - selectedShape.x;
                    const dy = pos.y - selectedShape.y;
                    selectedShape.radius = Math.max(10, Math.sqrt(dx * dx + dy * dy)); 
                } else if (selectedShape.type === 'square') {
                    // El tama침o es 2 veces la distancia mayor desde el centro en el sistema rotado
                    selectedShape.size = Math.max(20, 2 * Math.max(Math.abs(rotatedX), Math.abs(rotatedY))); 
                } else if (selectedShape.type === 'triangle') {
                    selectedShape.base = Math.max(20, Math.abs(rotatedX) * 2);
                    const h_top_ref = selectedShape.height * 2 / 3; 
                    selectedShape.height = Math.max(20, (rotatedY + h_top_ref));
                }
            } else if (isDragging) {
                selectedShape.x = pos.x - dragOffsetX;
                selectedShape.y = pos.y - dragOffsetY;
                
                // Limitar al canvas
                selectedShape.x = Math.max(0, Math.min(canvas.width, selectedShape.x));
                selectedShape.y = Math.max(0, Math.min(canvas.height, selectedShape.y));
            } else {
                return;
            }
            
            drawShapes();
        }

        function handleMouseUp(e) {
            isDragging = false;
            isResizing = false;
            isRotating = false;
            
            // Restablecer el cursor predeterminado si no se est치 sobre una figura activa
            canvas.classList.remove('dragging', 'resizing', 'rotating');
            canvas.style.cursor = 'grab';
        }

        // -----------------------------------------------------
        // 4. ASIGNACI칍N DE EVENT LISTENERS
        // -----------------------------------------------------

        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseout', handleMouseUp); 

        canvas.addEventListener('touchstart', handleMouseDown);
        canvas.addEventListener('touchmove', handleMouseMove);
        canvas.addEventListener('touchend', handleMouseUp);
        canvas.addEventListener('touchcancel', handleMouseUp); 
        
    </script>
</body>
</html>
