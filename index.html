<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor Geom칠trico Avanzado</title>
    <!-- Carga de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos base y cursores personalizados */
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            background-color: #e2e8f0; /* Slate-200 */
        }
        #geometricCanvas {
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            border: 4px solid #1e293b; 
            background-color: white;
            width: 100%;
            max-width: 900px;
            height: 500px; 
            touch-action: none; /* CRUCIAL para evitar que el navegador capture el gesto de arrastre */
            cursor: default;
        }
        /* Cursors */
        .rotating { cursor: grab !important; }
        .dragging { cursor: grab !important; }
        .resizer-ns { cursor: ns-resize !important; } 
        .resizer-ew { cursor: ew-resize !important; } 
        .move-vertex { cursor: move !important; }
        .panning { cursor: all-scroll !important; } 
    </style>
</head>
<body class="p-4 flex flex-col items-center justify-start">

    <header class="text-center mb-8 w-full max-w-2xl">
        <h1 class="text-4xl font-extrabold text-gray-900 mb-2">
            游늻 Editor de Figuras Avanzado (Solo Interacci칩n Visual)
        </h1>
        <p class="text-gray-600 text-base">
            Edita formas arrastrando sus v칠rtices y controles. 
            <br>
            <span class="font-semibold text-sky-800">Escala para referencia: 10 p칤xeles = 1 cm.</span>
        </p>
    </header>

    <!-- Controles de Creaci칩n -->
    <div class="mb-6 flex flex-wrap justify-center gap-3 sm:gap-4 w-full max-w-3xl">
        <button onclick="addShape('circle')" class="flex-1 min-w-[120px] bg-sky-600 hover:bg-sky-700 text-white font-bold py-3 px-4 rounded-xl transition duration-300 shadow-md">
            Elipse
        </button>
        <button onclick="addShape('rectangle')" class="flex-1 min-w-[120px] bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-xl transition duration-300 shadow-md">
            Cuadril치tero
        </button>
        <button onclick="addShape('triangle')" class="flex-1 min-w-[120px] bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-xl transition duration-300 shadow-md">
            Tri치ngulo Libre
        </button>
        <button onclick="clearCanvas()" class="w-full sm:w-auto bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-xl transition duration-300 shadow-md">
            Limpiar
        </button>
    </div>
    
    <!-- Bot칩n de Regularizaci칩n, Controles de Zoom -->
    <div class="mb-6 w-full max-w-3xl flex justify-between items-start gap-4 flex-wrap">
        <!-- Regularizar -->
        <div id="regularizeButtonContainer" class="hidden min-w-[150px]">
            <button id="regularizeButton" onclick="regularizeShape()" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-6 rounded-xl transition duration-300 shadow-lg text-sm sm:text-base">
                Establecer Forma Regular
            </button>
        </div>

        <!-- Controles de Zoom -->
        <div class="flex items-center space-x-2 p-2 bg-white rounded-xl shadow-lg self-start ml-auto">
            <button onclick="zoom(1/1.1)" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold w-10 h-10 rounded-full transition duration-150 text-xl">-</button>
            <span id="zoomLevel" class="text-sm font-semibold text-gray-700 w-12 text-center">100%</span>
            <button onclick="zoom(1.1)" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold w-10 h-10 rounded-full transition duration-150 text-xl">+</button>
        </div>
    </div>

    <!-- 츼rea de dibujo -->
    <div class="w-full flex justify-center">
        <canvas id="geometricCanvas" class="rounded-xl"></canvas>
    </div>

    <script>
        const canvas = document.getElementById("geometricCanvas");
        const ctx = canvas.getContext("2d");
        const regularizeButtonContainer = document.getElementById('regularizeButtonContainer');
        const zoomLevelSpan = document.getElementById('zoomLevel');

        // --- Configuraci칩n y Estado Global ---
        const DEG_TO_RAD = Math.PI / 180;
        const PIXELS_PER_CM = 10; // Definici칩n de la escala: 10 p칤xeles = 1 cm
        
        let shapes = []; 
        let selectedShape = null; 
        let actionState = null; 
        let dragOffset = { x: 0, y: 0 }; 
        let resizeControlIndex = -1; 
        
        // Aumentado para mejor interacci칩n t치ctil en m칩vil
        const controlSize = 12; 
        
        const minRadius = 5;

        // --- Variables de Zoom y Panor치mica ---
        let scale = 1.0;
        let offsetX = 0; 
        let offsetY = 0; 
        const maxScale = 3.0;
        const minScale = 0.2;
        
        // -----------------------------------------------------
        // UTILIDADES Y C츼LCULOS GEOM칄TRICOS
        // -----------------------------------------------------

        function getScreenPos(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX = e.clientX;
            let clientY = e.clientY;
            
            // Soporte para touch
            if (e.touches && e.touches.length) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }
        
        function getWorldPos(e) {
            const screenPos = getScreenPos(e);
            return {
                // Un-pan and un-scale
                x: (screenPos.x - offsetX) / scale,
                y: (screenPos.y - offsetY) / scale
            };
        }

        function globalToLocal(gx, gy, shape) {
            const dx = gx - shape.x;
            const dy = gy - shape.y;
            const cosA = Math.cos(-shape.rotation);
            const sinA = Math.sin(-shape.rotation);
            return {
                x: dx * cosA - dy * sinA,
                y: dx * sinA + dy * cosA
            };
        }

        function localToGlobal(lx, ly, shape) {
            const cosA = Math.cos(shape.rotation);
            const sinA = Math.sin(shape.rotation);
            return {
                x: shape.x + lx * cosA - ly * sinA,
                y: shape.y + lx * sinA + ly * cosA
            };
        }
        
        function getBoundingBox(vertices) {
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            if (vertices.length === 0) return { minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0 };
            vertices.forEach(v => {
                minX = Math.min(minX, v.x);
                minY = Math.min(minY, v.y);
                maxX = Math.max(maxX, v.x);
                maxY = Math.max(maxY, v.y);
            });
            return { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY };
        }

        function getPolygonSideLength(v1, v2) {
            const dx = v2.x - v1.x;
            const dy = v2.y - v1.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // -----------------------------------------------------
        // C츼LCULO DE CONTROLES
        // -----------------------------------------------------

        function getPolygonControls(shape) {
            const controls = { resize: [], rotate: null };
            const vertices = shape.vertices;
            const bb = getBoundingBox(vertices);
            const maxDimension = Math.max(bb.width, bb.height);
            const vertexCount = vertices.length;

            // V칠rtices (corners)
            for (let i = 0; i < vertexCount; i++) {
                const globalPos = localToGlobal(vertices[i].x, vertices[i].y, shape);
                controls.resize.push({
                    x: globalPos.x, y: globalPos.y, index: i, type: 'corner',
                    cursorClass: 'move-vertex', size: controlSize / scale 
                });
            }

            // Puntos medios de las aristas (midpoints)
            for (let i = 0; i < vertexCount; i++) {
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % vertexCount]; 
                const midX = (v1.x + v2.x) / 2;
                const midY = (v1.y + v2.y) / 2;
                
                const globalPos = localToGlobal(midX, midY, shape);
                controls.resize.push({
                    x: globalPos.x, y: globalPos.y, index: i + vertexCount, type: 'midpoint',
                    cursorClass: 'move-vertex', size: controlSize / scale 
                });
            }
            return { controls, maxDimension };
        }

        function getEllipseControls(shape) {
            const controls = { resize: [], rotate: null };
            const halfW = shape.rx;
            const halfH = shape.ry;
            const maxDimension = Math.max(shape.rx, shape.ry) * 2;
            const margin = 10 / scale; 

            const ellipseControlsData = [
                { xLocal: 1, yLocal: 0, cursor: 'resizer-ew', axis: 'x', type: 'midpoint' }, 
                { xLocal: -1, yLocal: 0, cursor: 'resizer-ew', axis: 'x', type: 'midpoint' },
                { xLocal: 0, yLocal: 1, cursor: 'resizer-ns', axis: 'y', type: 'midpoint' }, 
                { xLocal: 0, yLocal: -1, cursor: 'resizer-ns', axis: 'y', type: 'midpoint' } 
            ];

            ellipseControlsData.forEach((data, index) => {
                let localX = halfW * data.xLocal;
                let localY = halfH * data.yLocal;
                
                // Add a slight margin outside the shape for easier clicking
                localX += (data.xLocal !== 0 ? (data.xLocal > 0 ? margin : -margin) : 0);
                localY += (data.yLocal !== 0 ? (data.yLocal > 0 ? margin : -margin) : 0);

                const globalPos = localToGlobal(localX, localY, shape);
                controls.resize.push({
                    x: globalPos.x, y: globalPos.y, index: index, type: data.type,
                    cursorClass: data.cursor, size: controlSize / scale, axis: data.axis
                });
            });

            return { controls, maxDimension };
        }
        
        function getShapeControls(shape) {
            let controls = { resize: [], rotate: null };
            let maxDimension = 0;

            const isPolygon = shape.type === 'rectangle' || shape.type === 'triangle';

            if (isPolygon) {
                ({ controls, maxDimension } = getPolygonControls(shape));
            } else if (shape.type === 'circle') {
                ({ controls, maxDimension } = getEllipseControls(shape));
            }
            
            // Rotation Control (always positioned diagonally from the center)
            if (maxDimension > 0) {
                const rotationControlDistance = (maxDimension / 2) + (40 / scale); 
                const rotateAngle = shape.rotation + (225 * DEG_TO_RAD); 
                
                controls.rotate = {
                    x: shape.x + Math.cos(rotateAngle) * rotationControlDistance,
                    y: shape.y + Math.sin(rotateAngle) * rotationControlDistance,
                    size: controlSize / scale
                };
            }

            return controls;
        }

        // -----------------------------------------------------
        // DIBUJO
        // -----------------------------------------------------

        function getRandomColor() {
            const colors = ['#f59e0b', '#10b981', '#ef4444', '#3b82f6', '#8b5cf6'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function drawControl(ctrl) {
            ctx.save();
            ctx.beginPath();
            
            const strokeWidth = 2 / scale; 

            ctx.fillStyle = ctrl.type === 'corner' ? '#2563eb' : '#fbbf24'; 
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = strokeWidth;

            ctx.arc(ctrl.x, ctrl.y, ctrl.size, 0, 2 * Math.PI);
           
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        /**
         * Draws and labels the side lengths of a polygon.
         */
        function drawPolygonSideLabels(shape) {
            if (shape !== selectedShape || (shape.type !== 'rectangle' && shape.type !== 'triangle')) {
                return;
            }

            const vertices = shape.vertices;
            const vertexCount = vertices.length;

            ctx.save();
            ctx.font = `${14 / scale}px Inter`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#1e3a8a'; 
            
            for (let i = 0; i < vertexCount; i++) {
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % vertexCount];
                
                const lengthPx = getPolygonSideLength(v1, v2);
                const lengthCm = (lengthPx / PIXELS_PER_CM).toFixed(2);
                
                const midX = (v1.x + v2.x) / 2;
                const midY = (v1.y + v2.y) / 2;
                
                let angle = Math.atan2(v2.y - v1.y, v2.x - v1.x);

                if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
                    angle += Math.PI;
                }
                
                const globalPos = localToGlobal(midX, midY, shape);

                ctx.save();
                ctx.translate(globalPos.x, globalPos.y);
                ctx.rotate(angle + shape.rotation); 

                const textYOffset = -15 / scale; 
                
                // White stroke for text visibility against the shape
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4 / scale;
                ctx.strokeText(`${lengthCm} cm`, 0, textYOffset); 

                ctx.fillText(`${lengthCm} cm`, 0, textYOffset);

                ctx.restore();
            }

            ctx.restore();
        }


        function drawShape(shape) {
            ctx.save(); 

            ctx.translate(shape.x, shape.y);
            ctx.rotate(shape.rotation);

            ctx.beginPath();
            ctx.fillStyle = shape.color;
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 2 / scale; 

            if (shape.type === 'circle') {
                ctx.ellipse(0, 0, shape.rx, shape.ry, 0, 0, 2 * Math.PI);

            } else if (shape.type === 'rectangle' || shape.type === 'triangle') {
                const vertices = shape.vertices;
                if (vertices.length > 0) {
                    ctx.moveTo(vertices[0].x, vertices[0].y); 
                    for (let i = 1; i < vertices.length; i++) {
                        ctx.lineTo(vertices[i].x, vertices[i].y);
                    }
                    ctx.closePath();
                }
            }

            ctx.fill();
            ctx.stroke();

            ctx.restore(); 

            if (shape === selectedShape) {
                const controls = getShapeControls(shape);
                
                controls.resize.forEach(drawControl);

                const rotateCtrl = controls.rotate;
                if (rotateCtrl) {
                    ctx.beginPath();
                    ctx.arc(rotateCtrl.x, rotateCtrl.y, rotateCtrl.size, 0, 2 * Math.PI);
                    ctx.fillStyle = '#16a34a'; 
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2 / scale;
                    ctx.fill();
                    ctx.stroke();
                }

                if (shape.type === 'rectangle' || shape.type === 'triangle') {
                     drawPolygonSideLabels(shape); 
                }
               
                if (shape.type === 'circle') {
                    // Draw dimension labels for circle
                    const dimensions = [
                        { label: 'Rx', value: (shape.rx / PIXELS_PER_CM).toFixed(2) },
                        { label: 'Ry', value: (shape.ry / PIXELS_PER_CM).toFixed(2) }
                    ];

                    ctx.save();
                    ctx.fillStyle = '#1e3a8a'; 
                    ctx.font = `${14 / scale}px Inter`; 
                    ctx.textAlign = 'center';
                    
                    const textY = shape.y + Math.max(shape.ry, shape.rx) + (35 / scale);

                    dimensions.forEach((dim, index) => {
                        ctx.fillText(
                            `${dim.label}: ${dim.value} cm`, 
                            shape.x, 
                            textY + (index * 20 / scale) 
                        );
                    });
                    ctx.restore();
                }
            }
        }

        function drawShapes() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(offsetX, offsetY); 
            ctx.scale(scale, scale);         

            for(let i = shapes.length - 1; i >= 0; i--) {
                drawShape(shapes[i]);
            }

            ctx.restore(); 
            
            updateRegularizeButtonVisibility();
            updateZoomLevelDisplay();
        }

        // -----------------------------------------------------
        // GESTI칍N DE VISTA (ZOOM & PAN)
        // -----------------------------------------------------

        function updateZoomLevelDisplay() {
            zoomLevelSpan.textContent = `${Math.round(scale * 100)}%`;
        }

        function zoom(factor, mouseX = canvas.width / 2, mouseY = canvas.height / 2) {
            const oldScale = scale;
            const newScale = Math.min(maxScale, Math.max(minScale, scale * factor));
            
            if (newScale !== oldScale) {
                const scaleRatio = newScale / oldScale;
                
                // Adjust offset to zoom centered on the mouse/touch point
                offsetX = mouseX - scaleRatio * (mouseX - offsetX);
                offsetY = mouseY - scaleRatio * (mouseY - offsetY);

                scale = newScale;
                drawShapes();
            }
        }

        function handleWheel(e) {
            e.preventDefault(); 
            const screenPos = getScreenPos(e); 
            const factor = e.deltaY < 0 ? 1.1 : 1 / 1.1; 
            
            zoom(factor, screenPos.x, screenPos.y);
        }

        // -----------------------------------------------------
        // INICIALIZACI칍N Y L칍GICA DE FORMAS
        // -----------------------------------------------------

        function resizeCanvas() {
            const containerWidth = canvas.parentElement.clientWidth;
            canvas.width = Math.min(containerWidth, 900);
            canvas.height = 500; 
            drawShapes();
        }
        window.addEventListener('resize', resizeCanvas);
        window.onload = resizeCanvas; 

        function updateRegularizeButtonVisibility() {
            if (selectedShape && (selectedShape.type === 'circle' || selectedShape.type === 'rectangle' || selectedShape.type === 'triangle')) {
                regularizeButtonContainer.classList.remove('hidden');
            } else {
                regularizeButtonContainer.classList.add('hidden');
            }
        }

        function addShape(type) {
            const color = getRandomColor();
            // Center in the current view
            const x = (canvas.width / 2 - offsetX) / scale; 
            const y = (canvas.height / 2 - offsetY) / scale;
            let newShape;

            if (type === 'circle') {
                const initialRadius = 50; 
                newShape = { type: 'circle', x, y, rx: initialRadius, ry: initialRadius, color, rotation: 0 };
            } else if (type === 'rectangle') {
                const initialSize = 50; 
                newShape = { 
                    type: 'rectangle', x, y, rotation: 0, color, 
                    vertices: [
                        { x: -initialSize, y: -initialSize }, { x: initialSize, y: -initialSize },
                        { x: initialSize, y: initialSize }, { x: -initialSize, y: initialSize }
                    ]
                };
            } else if (type === 'triangle') {
                const initialBase = 100; 
                const initialHeight = 100; 
                newShape = { 
                    type: 'triangle', x, y, rotation: 0, color, 
                    vertices: [
                        { x: 0, y: -initialHeight / 2 },      
                        { x: initialBase / 2, y: initialHeight / 2 }, 
                        { x: -initialBase / 2, y: initialHeight / 2 }
                    ]
                };
            }

            shapes.unshift(newShape); 
            selectedShape = newShape;
            drawShapes();
        }

        function clearCanvas() {
            shapes = [];
            selectedShape = null;
            drawShapes();
        }

        function regularizeShape() {
            if (!selectedShape) return;

            if (selectedShape.type === 'circle') {
                const maxRadius = Math.max(selectedShape.rx, selectedShape.ry);
                selectedShape.rx = maxRadius;
                selectedShape.ry = maxRadius;
                
            } else if (selectedShape.type === 'rectangle') {
                const bb = getBoundingBox(selectedShape.vertices);
                const avgSide = (bb.width + bb.height) / 2; 
                const halfSide = avgSide / 2;

                selectedShape.vertices = [
                    { x: -halfSide, y: -halfSide }, { x: halfSide, y: -halfSide },
                    { x: halfSide, y: halfSide }, { x: -halfSide, y: halfSide }
                ];
                
            } else if (selectedShape.type === 'triangle') {
                const side1 = getPolygonSideLength(selectedShape.vertices[0], selectedShape.vertices[1]);
                const side2 = getPolygonSideLength(selectedShape.vertices[1], selectedShape.vertices[2]);
                const side3 = getPolygonSideLength(selectedShape.vertices[2], selectedShape.vertices[0]);
                const sideLength = (side1 + side2 + side3) / 3; 

                const h = (Math.sqrt(3) / 2) * sideLength; 
                const halfSide = sideLength / 2;
                
                selectedShape.vertices = [
                    { x: 0, y: -h / 2 }, { x: halfSide, y: h / 2 }, 
                    { x: -halfSide, y: h / 2 }
                ];
            }

            drawShapes();
        }


        // -----------------------------------------------------
        // INTERACCI칍N (MOVIMIENTO Y EDICI칍N)
        // -----------------------------------------------------

        function isPointInShape(mx, my, shape) {
            const { x: localX, y: localY } = globalToLocal(mx, my, shape);

            if (shape.type === 'circle') {
                // Check if point is inside the ellipse
                return (Math.pow(localX / shape.rx, 2) + Math.pow(localY / shape.ry, 2) <= 1);
            } 
            
            if (shape.type === 'rectangle' || shape.type === 'triangle') {
                // Simplified Bounding Box hit test for polygons
                const bb = getBoundingBox(shape.vertices);
                const minX = bb.minX;
                const maxX = bb.maxX;
                const minY = bb.minY;
                const maxY = bb.maxY;
                
                return (localX >= minX && localX <= maxX && localY >= minY && localY <= maxY);
            }
            
            return false;
        }

        function getControlHit(mx, my, shape) {
            if (!shape) return { action: null, index: -1, cursor: 'default' };

            const controls = getShapeControls(shape);
            // Tolerancia aumentada para m칩vil
            const tolerance = 15 / scale; 
            
            // 1. Rotation Control
            if (controls.rotate) {
                const distRotate = Math.sqrt(Math.pow(mx - controls.rotate.x, 2) + Math.pow(my - controls.rotate.y, 2));
                if (distRotate < controls.rotate.size + tolerance) {
                    return { action: 'rotate', index: -1, cursor: 'rotating' };
                }
            }

            // 2. Resize/Vertex Controls
            for (const ctrl of controls.resize) {
                const distResize = Math.sqrt(Math.pow(mx - ctrl.x, 2) + Math.pow(my - ctrl.y, 2));
                if (distResize < ctrl.size + tolerance) {
                    return { action: 'resize', index: ctrl.index, cursor: ctrl.cursorClass, axis: ctrl.axis };
                }
            }

            return { action: null, index: -1, cursor: 'default' };
        }

        function handlePolygonResize(shape, localMouseX, localMouseY, resizeControlIndex) {
            const vertices = shape.vertices;
            const vertexCount = vertices.length;
            
            if (resizeControlIndex < vertexCount) {
                // Moving a vertex (corner)
                const vertexIndex = resizeControlIndex;
                vertices[vertexIndex].x = localMouseX;
                vertices[vertexIndex].y = localMouseY;
                
            } else {
                // Moving a midpoint (translates the edge)
                const edgeIndex = resizeControlIndex - vertexCount;
                const v1Index = edgeIndex;
                const v2Index = (edgeIndex + 1) % vertexCount;
                
                const v1 = vertices[v1Index];
                const v2 = vertices[v2Index];
                const currentMidX = (v1.x + v2.x) / 2;
                const currentMidY = (v1.y + v2.y) / 2;
                
                const dx = localMouseX - currentMidX;
                const dy = localMouseY - currentMidY;
                
                v1.x += dx;
                v1.y += dy;
                v2.x += dx;
                v2.y += dy;
            }
        }
        
        function handleEllipseResize(shape, localMouseX, localMouseY, hit) {
            const axis = hit.axis;
            
            // Only use the absolute value relative to the center for resizing
            if (axis === 'x') {
                shape.rx = Math.max(minRadius, Math.abs(localMouseX));
            } else if (axis === 'y') {
                shape.ry = Math.max(minRadius, Math.abs(localMouseY));
            }
        }

        // -----------------------------------------------------
        // MANEJADORES DE EVENTOS
        // -----------------------------------------------------

        let lastHit = null; 

        function handleMouseDown(e) {
            // Evitar el scroll/zoom del navegador inmediatamente en touch
            if (e.touches) {
                e.preventDefault(); 
            }
            
            const worldPos = getWorldPos(e); 
            const screenPos = getScreenPos(e); 
            
            // Check if click is on canvas
            if (e.target !== canvas) {
                return;
            }

            selectedShape = null;
            actionState = null;
            resizeControlIndex = -1;
            lastHit = null;

            // 1. Try to hit a control or a shape
            // Iterar de adelante hacia atr치s (lo 칰ltimo dibujado es lo primero)
            for (let i = 0; i < shapes.length; i++) {
                const shape = shapes[i];
                const hit = getControlHit(worldPos.x, worldPos.y, shape);

                if (hit.action) {
                    selectedShape = shape;
                    actionState = hit.action;
                    resizeControlIndex = hit.index; 
                    canvas.className = hit.cursor;
                    lastHit = hit; 
                    
                    // Bring to front
                    shapes.splice(i, 1);
                    shapes.unshift(selectedShape);
                    break;
                } else if (isPointInShape(worldPos.x, worldPos.y, shape)) {
                    selectedShape = shape;
                    actionState = 'drag';
                    dragOffset.x = worldPos.x - shape.x; 
                    dragOffset.y = worldPos.y - shape.y;
                    canvas.className = 'dragging';

                    // Bring to front
                    shapes.splice(i, 1);
                    shapes.unshift(selectedShape);
                    break;
                }
            }
            
            // 2. If no shape was selected, start PANNING (movimiento de la vista)
            if (!selectedShape) {
                actionState = 'pan';
                dragOffset.x = screenPos.x; 
                dragOffset.y = screenPos.y;
                canvas.className = 'panning';
            }
            
            drawShapes();
        }

        function handleMouseMove(e) {
            // Evitar el scroll/zoom del navegador para que funcione el drag/pan
            e.preventDefault(); 
            
            const worldPos = getWorldPos(e); 
            const screenPos = getScreenPos(e); 

            // Panning Logic (Movimiento de la vista)
            if (actionState === 'pan') {
                const dx = screenPos.x - dragOffset.x;
                const dy = screenPos.y - dragOffset.y;

                offsetX += dx;
                offsetY += dy;

                dragOffset.x = screenPos.x;
                dragOffset.y = screenPos.y;

                drawShapes();
                return;
            }
            
            // Cursor Hover Logic (Solo para mouse)
            if (actionState === null) {
                // Solo aplicar cursores en escritorio, no en touch
                if (!e.touches) { 
                    let hoverAction = 'default';
                    for(const shape of shapes) {
                        const hit = getControlHit(worldPos.x, worldPos.y, shape);
                        if (hit.action) {
                            hoverAction = hit.cursor;
                            break;
                        } else if (isPointInShape(worldPos.x, worldPos.y, shape)) {
                            hoverAction = 'dragging';
                            break;
                        }
                    }
                    canvas.className = hoverAction;
                }
                return;
            }

            // Shape Interaction Logic
            if (!selectedShape) return; 

            if (actionState === 'rotate') {
                const dx = worldPos.x - selectedShape.x;
                const dy = worldPos.y - selectedShape.y;
                selectedShape.rotation = Math.atan2(dy, dx) - (225 * DEG_TO_RAD); 

            } else if (actionState === 'resize') {
                const { x: localMouseX, y: localMouseY } = globalToLocal(worldPos.x, worldPos.y, selectedShape);
                
                if (selectedShape.type === 'rectangle' || selectedShape.type === 'triangle') {
                    handlePolygonResize(selectedShape, localMouseX, localMouseY, resizeControlIndex);
                    
                } else if (selectedShape.type === 'circle') {
                    handleEllipseResize(selectedShape, localMouseX, localMouseY, lastHit);
                }

            } else if (actionState === 'drag') {
                selectedShape.x = worldPos.x - dragOffset.x;
                selectedShape.y = worldPos.y - dragOffset.y;
            }
            
            drawShapes();
        }

        function handleMouseUp(e) {
            actionState = null;
            resizeControlIndex = -1;
            lastHit = null;
            
            canvas.className = 'default';
            drawShapes(); 
        }

        // -----------------------------------------------------
        // LISTENERS
        // -----------------------------------------------------

        // Eventos de Mouse
        canvas.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        
        // Eventos T치ctiles (Touch)
        // Usamos document para touchmove/touchend/touchcancel para seguir el dedo si sale del canvas
        canvas.addEventListener('touchstart', handleMouseDown);
        document.addEventListener('touchmove', handleMouseMove, { passive: false });
        document.addEventListener('touchend', handleMouseUp);
        document.addEventListener('touchcancel', handleMouseUp);
        
        // Evento de Rueda para Zoom (escritorio)
        canvas.addEventListener('wheel', handleWheel, { passive: false });
        
    </script>
</body>
</html>
