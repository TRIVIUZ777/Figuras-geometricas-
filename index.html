<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor Geom√©trico con Identificaci√≥n de IA</title>
    <!-- Carga de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos base y cursores personalizados */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e2e8f0; /* Slate-200 */
            min-height: 100vh;
            overflow-y: scroll;
        }
        #geometricCanvas {
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            border: 4px solid #1e293b; 
            background-color: white;
            width: 100%;
            max-width: 900px;
            height: 500px; 
            touch-action: none; 
            cursor: default;
        }
        /* Cursors for internal canvas interaction */
        .rotating { cursor: grab !important; }
        .dragging { cursor: grab !important; }
        .resizer-ns { cursor: ns-resize !important; } 
        .resizer-ew { cursor: ew-resize !important; } 
        .move-vertex { cursor: move !important; }
        .panning { cursor: all-scroll !important; } 

        /* Estilo para el selector de color */
        #colorPicker {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 32px;
            height: 32px;
            border: none;
            padding: 0;
            cursor: pointer;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        #colorPicker::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        #colorPicker::-webkit-color-swatch {
            border: none;
        }
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="p-4 flex flex-col items-center justify-start">

    <header class="text-center mb-8 w-full max-w-3xl">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-900 mb-2">
            üìê Editor de Figuras Avanzado
        </h1>
        <p class="text-gray-600 text-sm sm:text-base">
            Usa el arrastre del rat√≥n o la rueda para navegar y hacer zoom en el lienzo.
        </p>
    </header>

    <!-- Controles de Creaci√≥n -->
    <div class="mb-6 flex flex-wrap justify-center gap-3 sm:gap-4 w-full max-w-5xl">
        <button onclick="addShape('circle')" class="flex-1 min-w-[120px] bg-sky-600 hover:bg-sky-700 text-white font-bold py-3 px-4 rounded-xl transition duration-300 shadow-md">
            Elipse
        </button>
        <button onclick="addShape('rectangle')" class="flex-1 min-w-[120px] bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-xl transition duration-300 shadow-md">
            Cuadril√°tero
        </button>
        <button onclick="addShape('triangle')" class="flex-1 min-w-[120px] bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-xl transition duration-300 shadow-md">
            Tri√°ngulo Libre
        </button>
        <button onclick="identifyShapesWithAI()" id="aiIdentifyButton" class="flex-1 min-w-[120px] bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-xl transition duration-300 shadow-md flex items-center justify-center">
            <span id="aiButtonText">Identificar Figura (IA)</span>
            <div id="aiLoadingSpinner" class="loading-spinner ml-2 hidden"></div>
        </button>
        <button onclick="clearCanvas()" class="w-full sm:w-auto bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-xl transition duration-300 shadow-md">
            Limpiar Todo
        </button>
    </div>
    
    <!-- Controles de Edici√≥n y Zoom -->
    <div class="mb-4 w-full max-w-[920px] flex justify-between items-start gap-4 flex-wrap">
        
        <!-- Controles de Edici√≥n de Figura Seleccionada -->
        <div class="flex items-start gap-4 flex-wrap" id="shapeControlsContainer">
            
            <!-- Selector de Color -->
            <div id="colorControlContainer" class="hidden min-w-[150px] mt-2 bg-white p-3 rounded-xl shadow-lg flex items-center space-x-2 border border-gray-200">
                <label for="colorPicker" class="text-sm font-semibold text-gray-700">Relleno:</label>
                <input type="color" id="colorPicker" oninput="changeShapeColor(this.value)" class="h-8 w-8">
            </div>

            <!-- Bot√≥n de Duplicar -->
            <div id="duplicateButtonContainer" class="hidden min-w-[150px] mt-2">
                <button id="duplicateButton" onclick="duplicateSelectedShape()" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-xl transition duration-300 shadow-lg text-sm sm:text-base">
                    Duplicar Figura
                </button>
            </div>
            
            <!-- Bot√≥n de Regularizaci√≥n -->
            <div id="regularizeButtonContainer" class="hidden min-w-[150px] mt-2">
                <button id="regularizeButton" onclick="regularizeShape()" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-6 rounded-xl transition duration-300 shadow-lg text-sm sm:text-base">
                    Establecer Forma Regular
                </button>
            </div>
            
            <!-- Bot√≥n de Eliminaci√≥n -->
            <div id="deleteButtonContainer" class="hidden min-w-[150px] mt-2">
                <button id="deleteShapeButton" onclick="deleteSelectedShape()" class="bg-gray-800 hover:bg-gray-900 text-white font-bold py-3 px-6 rounded-xl transition duration-300 shadow-lg text-sm sm:text-base">
                    Eliminar Figura
                </button>
            </div>
        </div>

        <!-- Controles de Zoom -->
        <div class="flex items-center space-x-6 ml-auto mt-2 p-2 bg-white rounded-xl shadow-lg self-start">
            <button onclick="zoom(1/1.1)" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold w-10 h-10 rounded-full transition duration-150 text-xl">-</button>
            <span id="zoomLevel" class="text-sm font-semibold text-gray-700 w-12 text-center">100%</span>
            <button onclick="zoom(1.1)" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold w-10 h-10 rounded-full transition duration-150 text-xl">+</button>
        </div>
    </div>

    <!-- √Årea de dibujo -->
    <div class="w-full flex justify-center flex-col max-w-[900px] relative">
        <canvas id="geometricCanvas" class="rounded-xl flex-grow"></canvas>
    </div>

    <!-- √Årea de Resultado de IA -->
    <div id="aiResult" class="mt-6 p-4 w-full max-w-[900px] bg-white rounded-xl shadow-lg border-l-4 border-red-500 hidden">
        <h3 class="text-lg font-bold text-red-700 mb-2">Hip√≥tesis de la IA:</h3>
        <p id="aiResultText" class="text-gray-700 italic"></p>
    </div>

    <script>
        const canvas = document.getElementById("geometricCanvas");
        const ctx = canvas.getContext("2d");
        const regularizeButtonContainer = document.getElementById('regularizeButtonContainer');
        const deleteButtonContainer = document.getElementById('deleteButtonContainer'); 
        const duplicateButtonContainer = document.getElementById('duplicateButtonContainer'); // Nuevo contenedor
        const colorControlContainer = document.getElementById('colorControlContainer'); 
        const colorPicker = document.getElementById('colorPicker');                 
        const zoomLevelSpan = document.getElementById('zoomLevel');
        const aiResultDiv = document.getElementById('aiResult');
        const aiResultText = document.getElementById('aiResultText');
        const aiButtonText = document.getElementById('aiButtonText');
        const aiLoadingSpinner = document.getElementById('aiLoadingSpinner');
        
        // --- Configuraci√≥n y Estado Global ---
        const DEG_TO_RAD = Math.PI / 180;
        const PIXELS_PER_CM = 10; 
        
        let shapes = []; 
        let selectedShape = null; 
        let actionState = null; 
        let dragOffset = { x: 0, y: 0 }; 
        let resizeControlIndex = -1; 
        
        // ** TAMA√ëO DEL CONTROL EN P√çXELES DE PANTALLA (din√°mico al zoom) **
        const controlScreenRadius = 7; 
        const minRadius = 5;

        // --- Variables de Zoom y Panor√°mica ---
        let scale = 1.0;
        let offsetX = 0; 
        let offsetY = 0; 
        const maxScale = 3.0;
        const minScale = 0.2;
        
        // ** L√çMITES DE DESPLAZAMIENTO **
        const PAN_LIMIT = 300; 

        // --- Configuraci√≥n de la API de Gemini ---
        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
        
        // -----------------------------------------------------
        // UTILIDADES Y C√ÅLCULOS GEOM√âTRICOS
        // -----------------------------------------------------

        function getScreenPos(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX = e.clientX;
            let clientY = e.clientY;
            
            if (e.touches && e.touches.length) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }
        
        function getWorldPos(e) {
            const screenPos = getScreenPos(e);
            return {
                x: (screenPos.x - offsetX) / scale,
                y: (screenPos.y - offsetY) / scale
            };
        }

        function globalToLocal(gx, gy, shape) {
            const dx = gx - shape.x;
            const dy = gy - shape.y;
            const cosA = Math.cos(-shape.rotation);
            const sinA = Math.sin(-shape.rotation);
            return {
                x: dx * cosA - dy * sinA,
                y: dx * sinA + dy * cosA
            };
        }

        function localToGlobal(lx, ly, shape) {
            const cosA = Math.cos(shape.rotation);
            const sinA = Math.sin(shape.rotation);
            return {
                x: shape.x + lx * cosA - ly * sinA,
                y: shape.y + lx * sinA + ly * cosA
            };
        }
        
        function getBoundingBox(vertices) {
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            if (vertices.length === 0) return { minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0 };
            vertices.forEach(v => {
                minX = Math.min(minX, v.x);
                minY = Math.min(minY, v.y);
                maxX = Math.max(maxX, v.x);
                maxY = Math.max(maxY, v.y);
            });
            return { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY };
        }

        function getPolygonSideLength(v1, v2) {
            const dx = v2.x - v1.x;
            const dy = v2.y - v1.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // --- Funciones para Controles de Forma ---
        function getPolygonControls(shape) {
            const controls = { resize: [], rotate: null };
            const vertices = shape.vertices;
            const bb = getBoundingBox(vertices);
            const maxDimension = Math.max(bb.width, bb.height);
            const vertexCount = vertices.length;
            
            // TAMA√ëO DIN√ÅMICO DEL CONTROL EN COORDENADAS DEL MUNDO
            const controlWorldSize = controlScreenRadius / scale; 

            for (let i = 0; i < vertexCount; i++) {
                const globalPos = localToGlobal(vertices[i].x, vertices[i].y, shape);
                controls.resize.push({
                    x: globalPos.x, y: globalPos.y, index: i, type: 'corner',
                    cursorClass: 'move-vertex', size: controlWorldSize 
                });
            }

            for (let i = 0; i < vertexCount; i++) {
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % vertexCount]; 
                const midX = (v1.x + v2.x) / 2;
                const midY = (v1.y + v2.y) / 2;
                
                const globalPos = localToGlobal(midX, midY, shape);
                controls.resize.push({
                    x: globalPos.x, y: globalPos.y, index: i + vertexCount, type: 'midpoint',
                    cursorClass: 'move-vertex', size: controlWorldSize 
                });
            }
            return { controls, maxDimension };
        }

        function getEllipseControls(shape) {
            const controls = { resize: [], rotate: null };
            const halfW = shape.rx;
            const halfH = shape.ry;
            const maxDimension = Math.max(shape.rx, shape.ry) * 2;
            const margin = 10 / scale; 
            
            // TAMA√ëO DIN√ÅMICO DEL CONTROL EN COORDENADAS DEL MUNDO
            const controlWorldSize = controlScreenRadius / scale; 

            const ellipseControlsData = [
                { xLocal: 1, yLocal: 0, cursor: 'resizer-ew', axis: 'x', type: 'midpoint' }, 
                { xLocal: -1, yLocal: 0, cursor: 'resizer-ew', axis: 'x', type: 'midpoint' },
                { xLocal: 0, yLocal: 1, cursor: 'resizer-ns', axis: 'y', type: 'midpoint' }, 
                { xLocal: 0, yLocal: -1, cursor: 'resizer-ns', axis: 'y', type: 'midpoint' } 
            ];

            ellipseControlsData.forEach((data, index) => {
                let localX = halfW * data.xLocal;
                let localY = halfH * data.yLocal;
                
                localX += (data.xLocal !== 0 ? (data.xLocal > 0 ? margin : -margin) : 0);
                localY += (data.yLocal !== 0 ? (data.yLocal > 0 ? margin : -margin) : 0);

                const globalPos = localToGlobal(localX, localY, shape);
                controls.resize.push({
                    x: globalPos.x, y: globalPos.y, index: index, type: data.type,
                    cursorClass: data.cursor, size: controlWorldSize, axis: data.axis
                });
            });

            return { controls, maxDimension };
        }
        
        function getShapeControls(shape) {
            let controls = { resize: [], rotate: null };
            let maxDimension = 0;
            
            // TAMA√ëO DIN√ÅMICO DEL CONTROL EN COORDENADAS DEL MUNDO
            const controlWorldSize = controlScreenRadius / scale; 

            const isPolygon = shape.type === 'rectangle' || shape.type === 'triangle';

            if (isPolygon) {
                ({ controls, maxDimension } = getPolygonControls(shape));
            } else if (shape.type === 'circle') {
                ({ controls, maxDimension } = getEllipseControls(shape));
            }
            
            if (maxDimension > 0) {
                const rotationControlDistance = (maxDimension / 2) + (40 / scale); 
                const rotateAngle = shape.rotation + (225 * DEG_TO_RAD); 
                
                controls.rotate = {
                    x: shape.x + Math.cos(rotateAngle) * rotationControlDistance,
                    y: shape.y + Math.sin(rotateAngle) * rotationControlDistance,
                    size: controlWorldSize
                };
            }

            return controls;
        }


        // --- DIBUJO ---

        function getRandomColor() {
            // Usamos colores predefinidos que Tailwind usa para asegurar contraste
            const colors = ['#f59e0b', '#10b981', '#ef4444', '#3b82f6', '#8b5cf6'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function drawControl(ctrl) {
            ctx.save();
            ctx.beginPath();
            
            // El ancho del trazo tambi√©n debe ser din√°mico
            const strokeWidth = 2 / scale; 

            ctx.fillStyle = ctrl.type === 'corner' ? '#2563eb' : '#fbbf24'; 
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = strokeWidth;

            // El radio (ctrl.size) ya se calcul√≥ como controlScreenRadius / scale
            ctx.arc(ctrl.x, ctrl.y, ctrl.size, 0, 2 * Math.PI);
           
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        function drawPolygonSideLabels(shape) {
            if (shape !== selectedShape || (shape.type !== 'rectangle' && shape.type !== 'triangle')) {
                return;
            }

            const vertices = shape.vertices;
            const vertexCount = vertices.length;

            ctx.save();
            // El tama√±o de fuente tambi√©n es din√°mico para mantener la legibilidad
            ctx.font = `${14 / scale}px Inter`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#1e3a8a'; 
            
            for (let i = 0; i < vertexCount; i++) {
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % vertexCount];
                
                const lengthPx = getPolygonSideLength(v1, v2);
                const lengthCm = (lengthPx / PIXELS_PER_CM).toFixed(2);
                
                const midX = (v1.x + v2.x) / 2;
                const midY = (v1.y + v2.y) / 2;
                
                let angle = Math.atan2(v2.y - v1.y, v2.x - v1.x);

                if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
                    angle += Math.PI;
                }
                
                const globalPos = localToGlobal(midX, midY, shape);

                ctx.save();
                ctx.translate(globalPos.x, globalPos.y);
                ctx.rotate(angle + shape.rotation); 

                const textYOffset = -15 / scale; 
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4 / scale;
                ctx.strokeText(`${lengthCm} cm`, 0, textYOffset); 

                ctx.fillText(`${lengthCm} cm`, 0, textYOffset);

                ctx.restore();
            }

            ctx.restore();
        }


        function drawShape(shape) {
            ctx.save(); 

            ctx.translate(shape.x, shape.y);
            ctx.rotate(shape.rotation);

            ctx.beginPath();
            // El ancho de l√≠nea de la figura tambi√©n debe ser din√°mico
            ctx.fillStyle = shape.color; 
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 2 / scale; 

            if (shape.type === 'circle') {
                ctx.ellipse(0, 0, shape.rx, shape.ry, 0, 0, 2 * Math.PI);

            } else if (shape.type === 'rectangle' || shape.type === 'triangle') {
                const vertices = shape.vertices;
                if (vertices.length > 0) {
                    ctx.moveTo(vertices[0].x, vertices[0].y); 
                    for (let i = 1; i < vertices.length; i++) {
                        ctx.lineTo(vertices[i].x, vertices[i].y);
                    }
                    ctx.closePath();
                }
            }

            ctx.fill();
            ctx.stroke();

            ctx.restore(); 

            if (shape === selectedShape) {
                const controls = getShapeControls(shape);
                
                controls.resize.forEach(drawControl);

                const rotateCtrl = controls.rotate;
                if (rotateCtrl) {
                    ctx.beginPath();
                    // El radio tambi√©n se ha calculado din√°micamente
                    ctx.arc(rotateCtrl.x, rotateCtrl.y, rotateCtrl.size, 0, 2 * Math.PI);
                    ctx.fillStyle = '#16a34a'; 
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2 / scale;
                    ctx.fill();
                    ctx.stroke();
                }

                if (shape.type === 'rectangle' || shape.type === 'triangle') {
                     drawPolygonSideLabels(shape); 
                }
               
                if (shape.type === 'circle') {
                    const dimensions = [
                        { label: 'Rx', value: (shape.rx / PIXELS_PER_CM).toFixed(2) },
                        { label: 'Ry', value: (shape.ry / PIXELS_PER_CM).toFixed(2) }
                    ];

                    ctx.save();
                    ctx.fillStyle = '#1e3a8a'; 
                    // El tama√±o de fuente tambi√©n es din√°mico
                    ctx.font = `${14 / scale}px Inter`; 
                    ctx.textAlign = 'center';
                    
                    const textY = shape.y + Math.max(shape.ry, shape.rx) + (35 / scale);

                    dimensions.forEach((dim, index) => {
                        ctx.fillText(
                            `${dim.label}: ${dim.value} cm`, 
                            shape.x, 
                            textY + (index * 20 / scale) 
                        );
                    });
                    ctx.restore();
                }
            }
        }

        function drawShapes() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(offsetX, offsetY); 
            ctx.scale(scale, scale);         

            for(let i = shapes.length - 1; i >= 0; i--) {
                drawShape(shapes[i]);
            }

            ctx.restore(); 
            
            updateControlButtonsVisibility(); 
            updateZoomLevelDisplay();
        }

        // -----------------------------------------------------
        // GESTI√ìN DE VISTA (ZOOM & PAN)
        // -----------------------------------------------------

        function updateZoomLevelDisplay() {
            zoomLevelSpan.textContent = `${Math.round(scale * 100)}%`;
        }

        function zoom(factor, mouseX = canvas.width / 2, mouseY = canvas.height / 2) {
            const oldScale = scale;
            const newScale = Math.min(maxScale, Math.max(minScale, scale * factor));
            
            if (newScale !== oldScale) {
                const scaleRatio = newScale / oldScale;
                
                offsetX = mouseX - scaleRatio * (mouseX - offsetX);
                offsetY = mouseY - scaleRatio * (mouseY - offsetY);

                scale = newScale;
                
                applyPanLimits(); 
                
                drawShapes();
            }
        }
        
        function handleWheel(e) {
            e.preventDefault(); 
            const screenPos = getScreenPos(e); 
            const factor = e.deltaY < 0 ? 1.1 : 1 / 1.1; 
            
            zoom(factor, screenPos.x, screenPos.y);
        }

        /**
         * Aplica l√≠mites al desplazamiento (offset) para que el lienzo no se pierda.
         */
        function applyPanLimits() {
            const maxLimitX = canvas.width / 2 + PAN_LIMIT * scale; 
            const minLimitX = canvas.width / 2 - PAN_LIMIT * scale; 

            const maxLimitY = canvas.height / 2 + PAN_LIMIT * scale;
            const minLimitY = canvas.height / 2 - PAN_LIMIT * scale;
            
            offsetX = Math.min(maxLimitX, Math.max(minLimitX, offsetX));
            offsetY = Math.min(maxLimitY, Math.max(minLimitY, offsetY));
        }

        // -----------------------------------------------------
        // INICIALIZACI√ìN Y L√ìGICA DE FORMAS
        // -----------------------------------------------------

        function resizeCanvas() {
            const containerWidth = canvas.parentElement.clientWidth;
            canvas.width = Math.min(containerWidth, 900);
            canvas.height = 500; 
            
            // Resetear el offset para que el centro del mundo (0,0) est√© en el centro de la pantalla
            offsetX = canvas.width / 2;
            offsetY = canvas.height / 2;
            
            drawShapes();
        }

        window.addEventListener('resize', resizeCanvas);
        window.onload = function() {
            resizeCanvas();
            // Inicializaci√≥n de listener para el color picker
            colorPicker.addEventListener('input', (e) => changeShapeColor(e.target.value));
            // Centrar el mundo al cargar
            offsetX = canvas.width / 2;
            offsetY = canvas.height / 2;
            drawShapes();
        };
        
        /**
         * Cambia el color de la figura seleccionada.
         */
        function changeShapeColor(newColor) {
            if (selectedShape) {
                selectedShape.color = newColor;
                drawShapes();
            }
        }

        function updateControlButtonsVisibility() {
            const isShapeSelected = selectedShape !== null;
            const isRegularizable = isShapeSelected && (selectedShape.type === 'circle' || selectedShape.type === 'rectangle' || selectedShape.type === 'triangle');
            
            // 1. Visibilidad del Selector de Color
            if (isShapeSelected) {
                colorControlContainer.classList.remove('hidden');
                colorPicker.value = selectedShape.color || '#3b82f6'; // Sincroniza el picker
            } else {
                colorControlContainer.classList.add('hidden');
            }

            // 2. Visibilidad del Bot√≥n Duplicar
            if (isShapeSelected) {
                duplicateButtonContainer.classList.remove('hidden');
            } else {
                duplicateButtonContainer.classList.add('hidden');
            }
            
            // 3. Visibilidad del Bot√≥n Regularizar
            if (isRegularizable) {
                regularizeButtonContainer.classList.remove('hidden');
            } else {
                regularizeButtonContainer.classList.add('hidden');
            }
            
            // 4. Visibilidad del Bot√≥n Eliminar
            if (isShapeSelected) {
                deleteButtonContainer.classList.remove('hidden');
            } else {
                deleteButtonContainer.classList.add('hidden');
            }
        }

        function addShape(type) {
            const color = getRandomColor();
            const x = 0; 
            const y = 0;
            let newShape;

            if (type === 'circle') {
                const initialRadius = 50; 
                newShape = { type: 'circle', x, y, rx: initialRadius, ry: initialRadius, color, rotation: 0 };
            } else if (type === 'rectangle') {
                const initialSize = 50; 
                newShape = { 
                    type: 'rectangle', x, y, rotation: 0, color, 
                    vertices: [
                        { x: -initialSize, y: -initialSize }, { x: initialSize, y: -initialSize },
                        { x: initialSize, y: initialSize }, { x: -initialSize, y: initialSize }
                    ]
                };
            } else if (type === 'triangle') {
                const initialBase = 100; 
                const initialHeight = 100; 
                newShape = { 
                    type: 'triangle', x, y, rotation: 0, color, 
                    vertices: [
                        { x: 0, y: -initialHeight / 2 },      
                        { x: initialBase / 2, y: initialHeight / 2 }, 
                        { x: -initialBase / 2, y: initialHeight / 2 }
                    ]
                };
            }

            shapes.unshift(newShape); 
            selectedShape = newShape;
            drawShapes();
        }

        /**
         * Crea una copia profunda de la figura seleccionada y la a√±ade al lienzo.
         */
        function duplicateSelectedShape() {
            if (!selectedShape) return;

            // Uso de JSON para crear una copia profunda de la forma y sus v√©rtices
            const duplicatedShape = JSON.parse(JSON.stringify(selectedShape));
            
            // Desplazar ligeramente la copia para que sea visible
            const offset = 15; // Desplazamiento en p√≠xeles
            duplicatedShape.x += offset;
            duplicatedShape.y += offset;
            
            // A√±adir la nueva forma al inicio del array y seleccionarla
            shapes.unshift(duplicatedShape);
            selectedShape = duplicatedShape;
            
            drawShapes();
        }

        function clearCanvas() {
            shapes = [];
            selectedShape = null;
            aiResultDiv.classList.add('hidden'); // Ocultar resultado de IA
            drawShapes();
        }
        
        function deleteSelectedShape() {
            if (!selectedShape) return;

            const index = shapes.indexOf(selectedShape);
            if (index > -1) {
                shapes.splice(index, 1);
            }
            selectedShape = null;
            drawShapes();
        }

        function regularizeShape() {
            if (!selectedShape) return;

            if (selectedShape.type === 'circle') {
                const maxRadius = Math.max(selectedShape.rx, selectedShape.ry);
                selectedShape.rx = maxRadius;
                selectedShape.ry = maxRadius;
                
            } else if (selectedShape.type === 'rectangle') {
                const bb = getBoundingBox(selectedShape.vertices);
                const avgSide = (bb.width + bb.height) / 2; 
                const halfSide = avgSide / 2;

                selectedShape.vertices = [
                    { x: -halfSide, y: -halfSide }, { x: halfSide, y: -halfSide },
                    { x: halfSide, y: halfSide }, { x: -halfSide, y: halfSide }
                ];
                
            } else if (selectedShape.type === 'triangle') {
                const side1 = getPolygonSideLength(selectedShape.vertices[0], selectedShape.vertices[1]);
                const side2 = getPolygonSideLength(selectedShape.vertices[1], selectedShape.vertices[2]);
                const side3 = getPolygonSideLength(selectedShape.vertices[2], selectedShape.vertices[0]);
                const sideLength = (side1 + side2 + side3) / 3; 

                const h = (Math.sqrt(3) / 2) * sideLength; 
                const halfSide = sideLength / 2;
                
                selectedShape.vertices = [
                    { x: 0, y: -h / 2 }, { x: halfSide, y: h / 2 }, 
                    { x: -halfSide, y: h / 2 }
                ];
            }

            drawShapes();
        }
        
        // -----------------------------------------------------
        // L√ìGICA DE INTELIGENCIA ARTIFICIAL
        // -----------------------------------------------------

        /**
         * Serializa las propiedades geom√©tricas de las figuras a un texto legible para la IA.
         */
        function serializeShapesForAI() {
            if (shapes.length === 0) {
                return "No hay figuras dibujadas en el lienzo. P√≠dele al usuario que dibuje algo.";
            }

            const descriptions = shapes.map((shape, index) => {
                const rotationDeg = (shape.rotation * 180 / Math.PI).toFixed(1);
                let description = `Figura ${index + 1} (${shape.color}): Tipo: ${shape.type}, Rotaci√≥n: ${rotationDeg} grados.`;

                if (shape.type === 'circle') {
                    const rxCm = (shape.rx / PIXELS_PER_CM).toFixed(2);
                    const ryCm = (shape.ry / PIXELS_PER_CM).toFixed(2);
                    description += ` Dimensiones: Radio X = ${rxCm} cm, Radio Y = ${ryCm} cm.`;
                    if (rxCm === ryCm) {
                        description += ` (Es un c√≠rculo perfecto).`;
                    } else if (Math.abs(shape.rx - shape.ry) / Math.max(shape.rx, shape.ry) < 0.1) {
                        description += ` (Es casi un c√≠rculo).`;
                    } else {
                        description += ` (Es una elipse).`;
                    }
                } else if (shape.type === 'rectangle' || shape.type === 'triangle') {
                    const sides = [];
                    for (let i = 0; i < shape.vertices.length; i++) {
                        const v1 = shape.vertices[i];
                        const v2 = shape.vertices[(i + 1) % shape.vertices.length];
                        sides.push((getPolygonSideLength(v1, v2) / PIXELS_PER_CM).toFixed(2));
                    }
                    description += ` Lados (cm): [${sides.join(', ')}].`;

                    // Simple check for square/equilateral
                    if (shape.type === 'rectangle' && sides.length === 4 && 
                        Math.abs(sides[0] - sides[1]) < 0.5 && Math.abs(sides[0] - sides[2]) < 0.5) {
                        description += ` (Parece un cuadrado).`;
                    } else if (shape.type === 'triangle' && sides.length === 3 && 
                        Math.abs(sides[0] - sides[1]) < 0.5 && Math.abs(sides[0] - sides[2]) < 0.5) {
                        description += ` (Parece un tri√°ngulo equil√°tero).`;
                    } else if (shape.type === 'rectangle') {
                        description += ` (Parece un rect√°ngulo).`;
                    }
                }
                return description;
            }).join('\n');

            return `El lienzo contiene ${shapes.length} figuras. Intenta identificar qu√© objeto del mundo real podr√≠an representar estas formas, bas√°ndote en su composici√≥n y geometr√≠a:\n\n${descriptions}`;
        }
        
        async function callGeminiAI(prompt) {
            let attempt = 0;
            const maxAttempts = 3;
            const baseDelay = 1000; // 1 second

            while (attempt < maxAttempts) {
                try {
                    const payload = {
                        contents: [{ parts: [{ text: prompt }] }],
                        systemInstruction: {
                            parts: [{ text: "Eres un analista geom√©trico y de formas. Tu tarea es analizar un conjunto de descripciones de figuras geom√©tricas (c√≠rculos, elipses, cuadril√°teros, tri√°ngulos) y formular una hip√≥tesis de alto nivel sobre qu√© objeto, concepto o escena del mundo real se est√° intentando representar. Mant√©n la respuesta conversacional, √∫til, en espa√±ol y concisa." }]
                        },
                    };
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    const text = result.candidates?.[0]?.content?.parts?.[0]?.text || "Error: No se pudo obtener la respuesta de la IA.";
                    return text;

                } catch (error) {
                    console.error("Error al llamar a Gemini:", error);
                    attempt++;
                    if (attempt < maxAttempts) {
                        const delay = baseDelay * Math.pow(2, attempt);
                        console.log(`Reintentando en ${delay / 1000} segundos...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        return "Error: No se pudo conectar con el servicio de identificaci√≥n de IA despu√©s de varios intentos. Int√©ntalo de nuevo m√°s tarde.";
                    }
                }
            }
        }

        async function identifyShapesWithAI() {
            aiResultDiv.classList.add('hidden');
            
            const prompt = serializeShapesForAI();
            if (shapes.length === 0) {
                 aiResultText.innerHTML = "¬°Dibuja al menos una figura (Elipse, Cuadril√°tero o Tri√°ngulo) en el lienzo antes de intentar la identificaci√≥n!";
                 aiResultDiv.classList.remove('hidden');
                 return;
            }

            // Mostrar estado de carga
            aiButtonText.textContent = 'Analizando...';
            aiLoadingSpinner.classList.remove('hidden');
            
            try {
                const result = await callGeminiAI(prompt);
                aiResultText.innerHTML = result;
            } catch (error) {
                aiResultText.innerHTML = "Ocurri√≥ un error inesperado al procesar la solicitud.";
                console.error(error);
            } finally {
                // Ocultar estado de carga
                aiButtonText.textContent = 'Identificar Figura (IA)';
                aiLoadingSpinner.classList.add('hidden');
                aiResultDiv.classList.remove('hidden');
            }
        }


        // -----------------------------------------------------
        // INTERACCI√ìN (Manejadores de Mouse/Touch)
        // -----------------------------------------------------

        function isPointInShape(mx, my, shape) {
            const { x: localX, y: localY } = globalToLocal(mx, my, shape);

            if (shape.type === 'circle') {
                // Ecuaci√≥n de elipse
                return (Math.pow(localX / shape.rx, 2) + Math.pow(localY / shape.ry, 2) <= 1);
            } 
            
            if (shape.type === 'rectangle' || shape.type === 'triangle') {
                // Uso de Bounding Box (BB) para pol√≠gonos irregulares
                const bb = getBoundingBox(shape.vertices);
                return (localX >= bb.minX && localX <= bb.maxX && localY >= bb.minY && localY <= bb.maxY);
            }
            
            return false;
        }

        function getControlHit(mx, my, shape) {
            if (!shape) return { action: null, index: -1, cursor: 'default' };

            const controls = getShapeControls(shape);
            // La tolerancia de golpe debe ser constante en p√≠xeles de pantalla
            const tolerance = 15 / scale; 
            
            // Check Rotation Control
            if (controls.rotate) {
                const distRotate = Math.sqrt(Math.pow(mx - controls.rotate.x, 2) + Math.pow(my - controls.rotate.y, 2));
                if (distRotate < controls.rotate.size + tolerance) {
                    return { action: 'rotate', index: -1, cursor: 'rotating' };
                }
            }

            // Check Resize Controls
            for (const ctrl of controls.resize) {
                const distResize = Math.sqrt(Math.pow(mx - ctrl.x, 2) + Math.pow(my - ctrl.y, 2));
                if (distResize < ctrl.size + tolerance) {
                    return { action: 'resize', index: ctrl.index, cursor: ctrl.cursorClass, axis: ctrl.axis };
                }
            }

            return { action: null, index: -1, cursor: 'default' };
        }

        function handlePolygonResize(shape, localMouseX, localMouseY, resizeControlIndex) {
            const vertices = shape.vertices;
            const vertexCount = vertices.length;
            
            if (resizeControlIndex < vertexCount) {
                // Resize corner (Move vertex)
                const vertexIndex = resizeControlIndex;
                vertices[vertexIndex].x = localMouseX;
                vertices[vertexIndex].y = localMouseY;
                
            } else {
                // Resize midpoint (Move edge - implemented as moving both vertices)
                const edgeIndex = resizeControlIndex - vertexCount;
                const v1Index = edgeIndex;
                const v2Index = (edgeIndex + 1) % vertexCount;
                
                const v1 = vertices[v1Index];
                const v2 = vertices[v2Index];
                const currentMidX = (v1.x + v2.x) / 2;
                const currentMidY = (v1.y + v2.y) / 2;
                
                const dx = localMouseX - currentMidX;
                const dy = localMouseY - currentMidY;
                
                v1.x += dx;
                v1.y += dy;
                v2.x += dx;
                v2.y += dy;
            }
        }
        
        function handleEllipseResize(shape, localMouseX, localMouseY, hit) {
            const axis = hit.axis;
            
            // El redimensionamiento de la elipse se hace relativo a su centro (0,0 local)
            if (axis === 'x') {
                shape.rx = Math.max(minRadius, Math.abs(localMouseX));
            } else if (axis === 'y') {
                shape.ry = Math.max(minRadius, Math.abs(localMouseY));
            }
        }

        let lastHit = null; 

        function handleMouseDown(e) {
            e.preventDefault(); 
            
            const worldPos = getWorldPos(e); 
            const screenPos = getScreenPos(e); 
            
            if (e.target !== canvas) {
                return;
            }

            // Reiniciar estados
            selectedShape = null;
            actionState = null;
            resizeControlIndex = -1;
            lastHit = null;

            // 1. Intentar golpear un control o una forma
            for (let i = 0; i < shapes.length; i++) {
                const shape = shapes[i];
                const hit = getControlHit(worldPos.x, worldPos.y, shape);

                if (hit.action) {
                    // Control de Redimensionamiento o Rotaci√≥n
                    selectedShape = shape;
                    actionState = hit.action;
                    resizeControlIndex = hit.index; 
                    canvas.className = hit.cursor;
                    lastHit = hit; 
                    
                    // Mover la forma seleccionada al frente
                    shapes.splice(i, 1);
                    shapes.unshift(selectedShape);
                    break;
                } else if (isPointInShape(worldPos.x, worldPos.y, shape)) {
                    // Arrastre de Forma
                    selectedShape = shape;
                    actionState = 'drag';
                    dragOffset.x = worldPos.x - shape.x; 
                    dragOffset.y = worldPos.y - shape.y;
                    canvas.className = 'dragging';

                    // Mover la forma seleccionada al frente
                    shapes.splice(i, 1);
                    shapes.unshift(selectedShape);
                    break;
                }
            }
            
            // 2. Si no se seleccion√≥ nada, iniciar PANNING (arrastrar la vista)
            if (!selectedShape) {
                actionState = 'pan';
                dragOffset.x = screenPos.x; 
                dragOffset.y = screenPos.y;
                canvas.className = 'panning';
            }
            
            drawShapes();
        }

        function handleMouseMove(e) {
            
            if (actionState !== null) {
                e.preventDefault(); 
            }
            
            const worldPos = getWorldPos(e); 
            const screenPos = getScreenPos(e); 

            // L√≥gica de Panning (Movimiento de la vista por arrastre del canvas)
            if (actionState === 'pan') {
                const dx = screenPos.x - dragOffset.x;
                const dy = screenPos.y - dragOffset.y;

                offsetX += dx;
                offsetY += dy;

                applyPanLimits();

                dragOffset.x = screenPos.x;
                dragOffset.y = screenPos.y;

                drawShapes(); 
                return;
            }
            
            // L√≥gica de Hover del Cursor (Solo para mouse)
            if (actionState === null && !e.touches) {
                let hoverAction = 'default';
                for(const shape of shapes) {
                    const hit = getControlHit(worldPos.x, worldPos.y, shape);
                    if (hit.action) {
                        hoverAction = hit.cursor;
                        break;
                    } else if (isPointInShape(worldPos.x, worldPos.y, shape)) {
                        hoverAction = 'dragging';
                        break;
                    }
                }
                canvas.className = hoverAction;
                return;
            }

            if (actionState === null) return;

            // L√≥gica de Interacci√≥n con la Forma
            if (!selectedShape) return; 

            if (actionState === 'rotate') {
                const dx = worldPos.x - selectedShape.x;
                const dy = worldPos.y - selectedShape.y;
                // Ajustamos el √°ngulo de rotaci√≥n usando el desplazamiento (225 grados) del control de rotaci√≥n
                selectedShape.rotation = Math.atan2(dy, dx) - (225 * DEG_TO_RAD); 

            } else if (actionState === 'resize') {
                const { x: localMouseX, y: localMouseY } = globalToLocal(worldPos.x, worldPos.y, selectedShape);
                
                if (selectedShape.type === 'rectangle' || selectedShape.type === 'triangle') {
                    handlePolygonResize(selectedShape, localMouseX, localMouseY, resizeControlIndex);
                    
                } else if (selectedShape.type === 'circle') {
                    handleEllipseResize(selectedShape, localMouseX, localMouseY, lastHit);
                }

            } else if (actionState === 'drag') {
                selectedShape.x = worldPos.x - dragOffset.x;
                selectedShape.y = worldPos.y - dragOffset.y;
            }
            
            drawShapes();
        }

        function handleMouseUp(e) {
            actionState = null;
            resizeControlIndex = -1;
            lastHit = null;
            
            canvas.className = 'default';
            drawShapes(); 
        }

        // -----------------------------------------------------
        // LISTENERS
        // -----------------------------------------------------

        // Eventos de Mouse
        canvas.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        
        // Eventos T√°ctiles (Touch)
        canvas.addEventListener('touchstart', handleMouseDown); 
        document.addEventListener('touchmove', handleMouseMove, { passive: false });
        document.addEventListener('touchend', handleMouseUp);
        document.addEventListener('touchcancel', handleMouseUp);
        
        // Evento de Rueda para Zoom (escritorio)
        canvas.addEventListener('wheel', handleWheel, { passive: false });
        
    </script>
</body>
</html>
