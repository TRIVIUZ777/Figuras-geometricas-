<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor Geom茅trico Avanzado</title>
    <!-- Carga de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos base y cursores personalizados */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e2e8f0; /* Slate-200 */
            min-height: 100vh;
            overflow-y: scroll;
        }
        #geometricCanvas {
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            border: 4px solid #1e293b; 
            background-color: white;
            width: 100%;
            max-width: 900px;
            height: 500px; 
            touch-action: none; 
            cursor: default;
        }
        /* Cursors for internal canvas interaction */
        .rotating { cursor: grab !important; }
        .dragging { cursor: grab !important; }
        .resizer-ns { cursor: ns-resize !important; } 
        .resizer-ew { cursor: ew-resize !important; } 
        .move-vertex { cursor: move !important; }
        .panning { cursor: all-scroll !important; } 

        /* Estilo para el selector de color (se asegura de que sea visible) */
        #colorPicker {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 32px;
            height: 32px;
            border: none;
            padding: 0;
            cursor: pointer;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        #colorPicker::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        #colorPicker::-webkit-color-swatch {
            border: none;
        }

    </style>
</head>
<body class="p-4 flex flex-col items-center justify-start">

    <header class="text-center mb-8 w-full max-w-3xl">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-900 mb-2">
             Editor de Figuras Avanzado
        </h1>
        <p class="text-gray-600 text-sm sm:text-base">
            Usa el arrastre del rat贸n o la rueda para navegar y hacer zoom en el lienzo.
            <span class="font-semibold text-sky-800">Escala: 10 p铆xeles = 1 cm.</span>
        </p>
    </header>

    <!-- Controles de Creaci贸n -->
    <div class="mb-6 flex flex-wrap justify-center gap-3 sm:gap-4 w-full max-w-3xl">
        <button onclick="addShape('circle')" class="flex-1 min-w-[120px] bg-sky-600 hover:bg-sky-700 text-white font-bold py-3 px-4 rounded-xl transition duration-300 shadow-md">
            Elipse
        </button>
        <button onclick="addShape('rectangle')" class="flex-1 min-w-[120px] bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-xl transition duration-300 shadow-md">
            Cuadril谩tero
        </button>
        <button onclick="addShape('triangle')" class="flex-1 min-w-[120px] bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-xl transition duration-300 shadow-md">
            Tri谩ngulo Libre
        </button>
        <button onclick="clearCanvas()" class="w-full sm:w-auto bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-xl transition duration-300 shadow-md">
            Limpiar Todo
        </button>
    </div>
    
    <!-- Controles de Edici贸n y Zoom -->
    <div class="mb-4 w-full max-w-[920px] flex justify-between items-start gap-4 flex-wrap">
        
        <!-- Controles de Edici贸n de Figura Seleccionada -->
        <div class="flex items-start gap-4 flex-wrap" id="shapeControlsContainer">
            
            <!-- Selector de Color -->
            <div id="colorControlContainer" class="hidden min-w-[150px] mt-2 bg-white p-3 rounded-xl shadow-lg flex items-center space-x-2 border border-gray-200">
                <label for="colorPicker" class="text-sm font-semibold text-gray-700">Relleno:</label>
                <input type="color" id="colorPicker" oninput="changeShapeColor(this.value)" class="h-8 w-8">
            </div>

            <!-- Bot贸n de Regularizaci贸n -->
            <div id="regularizeButtonContainer" class="hidden min-w-[150px] mt-2">
                <button id="regularizeButton" onclick="regularizeShape()" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-6 rounded-xl transition duration-300 shadow-lg text-sm sm:text-base">
                    Establecer Forma Regular
                </button>
            </div>
            
            <!-- Bot贸n de Eliminaci贸n -->
            <div id="deleteButtonContainer" class="hidden min-w-[150px] mt-2">
                <button id="deleteShapeButton" onclick="deleteSelectedShape()" class="bg-gray-800 hover:bg-gray-900 text-white font-bold py-3 px-6 rounded-xl transition duration-300 shadow-lg text-sm sm:text-base">
                    Eliminar Figura
                </button>
            </div>
        </div>

        <!-- Controles de Zoom -->
        <div class="flex items-center space-x-6 ml-auto mt-2 p-2 bg-white rounded-xl shadow-lg self-start">
            <button onclick="zoom(1/1.1)" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold w-10 h-10 rounded-full transition duration-150 text-xl">-</button>
            <span id="zoomLevel" class="text-sm font-semibold text-gray-700 w-12 text-center">100%</span>
            <button onclick="zoom(1.1)" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold w-10 h-10 rounded-full transition duration-150 text-xl">+</button>
        </div>
    </div>

    <!-- rea de dibujo -->
    <div class="w-full flex justify-center flex-col max-w-[900px] relative">
        <canvas id="geometricCanvas" class="rounded-xl flex-grow"></canvas>
    </div>

    <script>
        const canvas = document.getElementById("geometricCanvas");
        const ctx = canvas.getContext("2d");
        const regularizeButtonContainer = document.getElementById('regularizeButtonContainer');
        const deleteButtonContainer = document.getElementById('deleteButtonContainer'); 
        const colorControlContainer = document.getElementById('colorControlContainer'); 
        const colorPicker = document.getElementById('colorPicker');                 
        const zoomLevelSpan = document.getElementById('zoomLevel');
        
        // --- Configuraci贸n y Estado Global ---
        const DEG_TO_RAD = Math.PI / 180;
        const PIXELS_PER_CM = 10; 
        
        let shapes = []; 
        let selectedShape = null; 
        let actionState = null; 
        let dragOffset = { x: 0, y: 0 }; 
        let resizeControlIndex = -1; 
        
        // ** TAMAO DEL CONTROL EN PXELES DE PANTALLA **
        const controlScreenRadius = 7; 
        const minRadius = 5;

        // --- Variables de Zoom y Panor谩mica ---
        let scale = 1.0;
        let offsetX = 0; 
        let offsetY = 0; 
        const maxScale = 3.0;
        const minScale = 0.2;
        
        // ** LMITES DE DESPLAZAMIENTO **
        const PAN_LIMIT = 300; 

        // -----------------------------------------------------
        // UTILIDADES Y CLCULOS GEOMTRICOS
        // -----------------------------------------------------

        function getScreenPos(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX = e.clientX;
            let clientY = e.clientY;
            
            if (e.touches && e.touches.length) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }
        
        function getWorldPos(e) {
            const screenPos = getScreenPos(e);
            return {
                x: (screenPos.x - offsetX) / scale,
                y: (screenPos.y - offsetY) / scale
            };
        }

        function globalToLocal(gx, gy, shape) {
            const dx = gx - shape.x;
            const dy = gy - shape.y;
            const cosA = Math.cos(-shape.rotation);
            const sinA = Math.sin(-shape.rotation);
            return {
                x: dx * cosA - dy * sinA,
                y: dx * sinA + dy * cosA
            };
        }

        function localToGlobal(lx, ly, shape) {
            const cosA = Math.cos(shape.rotation);
            const sinA = Math.sin(shape.rotation);
            return {
                x: shape.x + lx * cosA - ly * sinA,
                y: shape.y + lx * sinA + ly * cosA
            };
        }
        
        function getBoundingBox(vertices) {
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            if (vertices.length === 0) return { minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0 };
            vertices.forEach(v => {
                minX = Math.min(minX, v.x);
                minY = Math.min(minY, v.y);
                maxX = Math.max(maxX, v.x);
                maxY = Math.max(maxY, v.y);
            });
            return { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY };
        }

        function getPolygonSideLength(v1, v2) {
            const dx = v2.x - v1.x;
            const dy = v2.y - v1.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // --- Funciones para Controles de Forma ---
        function getPolygonControls(shape) {
            const controls = { resize: [], rotate: null };
            const vertices = shape.vertices;
            const bb = getBoundingBox(vertices);
            const maxDimension = Math.max(bb.width, bb.height);
            const vertexCount = vertices.length;
            
            // ** TAMAO DINMICO DEL CONTROL EN COORDENADAS DEL MUNDO **
            const controlWorldSize = controlScreenRadius / scale; 

            for (let i = 0; i < vertexCount; i++) {
                const globalPos = localToGlobal(vertices[i].x, vertices[i].y, shape);
                controls.resize.push({
                    x: globalPos.x, y: globalPos.y, index: i, type: 'corner',
                    cursorClass: 'move-vertex', size: controlWorldSize 
                });
            }

            for (let i = 0; i < vertexCount; i++) {
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % vertexCount]; 
                const midX = (v1.x + v2.x) / 2;
                const midY = (v1.y + v2.y) / 2;
                
                const globalPos = localToGlobal(midX, midY, shape);
                controls.resize.push({
                    x: globalPos.x, y: globalPos.y, index: i + vertexCount, type: 'midpoint',
                    cursorClass: 'move-vertex', size: controlWorldSize 
                });
            }
            return { controls, maxDimension };
        }

        function getEllipseControls(shape) {
            const controls = { resize: [], rotate: null };
            const halfW = shape.rx;
            const halfH = shape.ry;
            const maxDimension = Math.max(shape.rx, shape.ry) * 2;
            const margin = 10 / scale; 
            
            // ** TAMAO DINMICO DEL CONTROL EN COORDENADAS DEL MUNDO **
            const controlWorldSize = controlScreenRadius / scale; 

            const ellipseControlsData = [
                { xLocal: 1, yLocal: 0, cursor: 'resizer-ew', axis: 'x', type: 'midpoint' }, 
                { xLocal: -1, yLocal: 0, cursor: 'resizer-ew', axis: 'x', type: 'midpoint' },
                { xLocal: 0, yLocal: 1, cursor: 'resizer-ns', axis: 'y', type: 'midpoint' }, 
                { xLocal: 0, yLocal: -1, cursor: 'resizer-ns', axis: 'y', type: 'midpoint' } 
            ];

            ellipseControlsData.forEach((data, index) => {
                let localX = halfW * data.xLocal;
                let localY = halfH * data.yLocal;
                
                localX += (data.xLocal !== 0 ? (data.xLocal > 0 ? margin : -margin) : 0);
                localY += (data.yLocal !== 0 ? (data.yLocal > 0 ? margin : -margin) : 0);

                const globalPos = localToGlobal(localX, localY, shape);
                controls.resize.push({
                    x: globalPos.x, y: globalPos.y, index: index, type: data.type,
                    cursorClass: data.cursor, size: controlWorldSize, axis: data.axis
                });
            });

            return { controls, maxDimension };
        }
        
        function getShapeControls(shape) {
            let controls = { resize: [], rotate: null };
            let maxDimension = 0;
            
            // ** TAMAO DINMICO DEL CONTROL EN COORDENADAS DEL MUNDO **
            const controlWorldSize = controlScreenRadius / scale; 

            const isPolygon = shape.type === 'rectangle' || shape.type === 'triangle';

            if (isPolygon) {
                ({ controls, maxDimension } = getPolygonControls(shape));
            } else if (shape.type === 'circle') {
                ({ controls, maxDimension } = getEllipseControls(shape));
            }
            
            if (maxDimension > 0) {
                const rotationControlDistance = (maxDimension / 2) + (40 / scale); 
                const rotateAngle = shape.rotation + (225 * DEG_TO_RAD); 
                
                controls.rotate = {
                    x: shape.x + Math.cos(rotateAngle) * rotationControlDistance,
                    y: shape.y + Math.sin(rotateAngle) * rotationControlDistance,
                    size: controlWorldSize
                };
            }

            return controls;
        }


        // --- DIBUJO ---

        function getRandomColor() {
            // Usamos colores predefinidos que Tailwind usa para asegurar contraste
            const colors = ['#f59e0b', '#10b981', '#ef4444', '#3b82f6', '#8b5cf6'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function drawControl(ctrl) {
            ctx.save();
            ctx.beginPath();
            
            // El ancho del trazo tambi茅n debe ser din谩mico
            const strokeWidth = 2 / scale; 

            ctx.fillStyle = ctrl.type === 'corner' ? '#2563eb' : '#fbbf24'; 
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = strokeWidth;

            // El radio (ctrl.size) ya se calcul贸 como controlScreenRadius / scale
            ctx.arc(ctrl.x, ctrl.y, ctrl.size, 0, 2 * Math.PI);
           
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        function drawPolygonSideLabels(shape) {
            if (shape !== selectedShape || (shape.type !== 'rectangle' && shape.type !== 'triangle')) {
                return;
            }

            const vertices = shape.vertices;
            const vertexCount = vertices.length;

            ctx.save();
            // El tama帽o de fuente tambi茅n es din谩mico para mantener la legibilidad
            ctx.font = `${14 / scale}px Inter`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#1e3a8a'; 
            
            for (let i = 0; i < vertexCount; i++) {
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % vertexCount];
                
                const lengthPx = getPolygonSideLength(v1, v2);
                const lengthCm = (lengthPx / PIXELS_PER_CM).toFixed(2);
                
                const midX = (v1.x + v2.x) / 2;
                const midY = (v1.y + v2.y) / 2;
                
                let angle = Math.atan2(v2.y - v1.y, v2.x - v1.x);

                if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
                    angle += Math.PI;
                }
                
                const globalPos = localToGlobal(midX, midY, shape);

                ctx.save();
                ctx.translate(globalPos.x, globalPos.y);
                ctx.rotate(angle + shape.rotation); 

                const textYOffset = -15 / scale; 
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4 / scale;
                ctx.strokeText(`${lengthCm} cm`, 0, textYOffset); 

                ctx.fillText(`${lengthCm} cm`, 0, textYOffset);

                ctx.restore();
            }

            ctx.restore();
        }


        function drawShape(shape) {
            ctx.save(); 

            ctx.translate(shape.x, shape.y);
            ctx.rotate(shape.rotation);

            ctx.beginPath();
            // El ancho de l铆nea de la figura tambi茅n debe ser din谩mico
            ctx.fillStyle = shape.color; 
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 2 / scale; 

            if (shape.type === 'circle') {
                ctx.ellipse(0, 0, shape.rx, shape.ry, 0, 0, 2 * Math.PI);

            } else if (shape.type === 'rectangle' || shape.type === 'triangle') {
                const vertices = shape.vertices;
                if (vertices.length > 0) {
                    ctx.moveTo(vertices[0].x, vertices[0].y); 
                    for (let i = 1; i < vertices.length; i++) {
                        ctx.lineTo(vertices[i].x, vertices[i].y);
                    }
                    ctx.closePath();
                }
            }

            ctx.fill();
            ctx.stroke();

            ctx.restore(); 

            if (shape === selectedShape) {
                const controls = getShapeControls(shape);
                
                controls.resize.forEach(drawControl);

                const rotateCtrl = controls.rotate;
                if (rotateCtrl) {
                    ctx.beginPath();
                    // El radio tambi茅n se ha calculado din谩micamente
                    ctx.arc(rotateCtrl.x, rotateCtrl.y, rotateCtrl.size, 0, 2 * Math.PI);
                    ctx.fillStyle = '#16a34a'; 
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2 / scale;
                    ctx.fill();
                    ctx.stroke();
                }

                if (shape.type === 'rectangle' || shape.type === 'triangle') {
                     drawPolygonSideLabels(shape); 
                }
               
                if (shape.type === 'circle') {
                    const dimensions = [
                        { label: 'Rx', value: (shape.rx / PIXELS_PER_CM).toFixed(2) },
                        { label: 'Ry', value: (shape.ry / PIXELS_PER_CM).toFixed(2) }
                    ];

                    ctx.save();
                    ctx.fillStyle = '#1e3a8a'; 
                    // El tama帽o de fuente tambi茅n es din谩mico
                    ctx.font = `${14 / scale}px Inter`; 
                    ctx.textAlign = 'center';
                    
                    const textY = shape.y + Math.max(shape.ry, shape.rx) + (35 / scale);

                    dimensions.forEach((dim, index) => {
                        ctx.fillText(
                            `${dim.label}: ${dim.value} cm`, 
                            shape.x, 
                            textY + (index * 20 / scale) 
                        );
                    });
                    ctx.restore();
                }
            }
        }

        function drawShapes() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(offsetX, offsetY); 
            ctx.scale(scale, scale);         

            for(let i = shapes.length - 1; i >= 0; i--) {
                drawShape(shapes[i]);
            }

            ctx.restore(); 
            
            updateControlButtonsVisibility(); 
            updateZoomLevelDisplay();
        }

        // -----------------------------------------------------
        // GESTIN DE VISTA (ZOOM & PAN)
        // -----------------------------------------------------

        function updateZoomLevelDisplay() {
            zoomLevelSpan.textContent = `${Math.round(scale * 100)}%`;
        }

        function zoom(factor, mouseX = canvas.width / 2, mouseY = canvas.height / 2) {
            const oldScale = scale;
            const newScale = Math.min(maxScale, Math.max(minScale, scale * factor));
            
            if (newScale !== oldScale) {
                const scaleRatio = newScale / oldScale;
                
                offsetX = mouseX - scaleRatio * (mouseX - offsetX);
                offsetY = mouseY - scaleRatio * (mouseY - offsetY);

                scale = newScale;
                
                applyPanLimits(); 
                
                drawShapes();
            }
        }
        
        function handleWheel(e) {
            e.preventDefault(); 
            const screenPos = getScreenPos(e); 
            const factor = e.deltaY < 0 ? 1.1 : 1 / 1.1; 
            
            zoom(factor, screenPos.x, screenPos.y);
        }

        /**
         * Aplica l铆mites al desplazamiento (offset) para que el lienzo no se pierda.
         */
        function applyPanLimits() {
            const maxLimitX = canvas.width / 2 + PAN_LIMIT * scale; 
            const minLimitX = canvas.width / 2 - PAN_LIMIT * scale; 

            const maxLimitY = canvas.height / 2 + PAN_LIMIT * scale;
            const minLimitY = canvas.height / 2 - PAN_LIMIT * scale;
            
            offsetX = Math.min(maxLimitX, Math.max(minLimitX, offsetX));
            offsetY = Math.min(maxLimitY, Math.max(minLimitY, offsetY));
        }

        // -----------------------------------------------------
        // INICIALIZACIN Y LGICA DE FORMAS
        // -----------------------------------------------------

        function resizeCanvas() {
            const containerWidth = canvas.parentElement.clientWidth;
            canvas.width = Math.min(containerWidth, 900);
            canvas.height = 500; 
            
            // Resetear el offset para que el centro del mundo (0,0) est茅 en el centro de la pantalla
            offsetX = canvas.width / 2;
            offsetY = canvas.height / 2;
            
            drawShapes();
        }

        window.addEventListener('resize', resizeCanvas);
        window.onload = function() {
            resizeCanvas();
            // Inicializaci贸n de listener para el color picker
            colorPicker.addEventListener('input', (e) => changeShapeColor(e.target.value));
        };
        
        /**
         * Cambia el color de la figura seleccionada.
         */
        function changeShapeColor(newColor) {
            if (selectedShape) {
                selectedShape.color = newColor;
                drawShapes();
            }
        }

        function updateControlButtonsVisibility() {
            const isShapeSelected = selectedShape !== null;
            const isRegularizable = isShapeSelected && (selectedShape.type === 'circle' || selectedShape.type === 'rectangle' || selectedShape.type === 'triangle');
            
            // 1. Visibilidad del Selector de Color
            if (isShapeSelected) {
                colorControlContainer.classList.remove('hidden');
                colorPicker.value = selectedShape.color || '#3b82f6'; // Sincroniza el picker
            } else {
                colorControlContainer.classList.add('hidden');
            }

            // 2. Visibilidad del Bot贸n Regularizar
            if (isRegularizable) {
                regularizeButtonContainer.classList.remove('hidden');
            } else {
                regularizeButtonContainer.classList.add('hidden');
            }
            
            // 3. Visibilidad del Bot贸n Eliminar
            if (isShapeSelected) {
                deleteButtonContainer.classList.remove('hidden');
            } else {
                deleteButtonContainer.classList.add('hidden');
            }
        }

        function addShape(type) {
            const color = getRandomColor();
            const x = 0; 
            const y = 0;
            let newShape;

            if (type === 'circle') {
                const initialRadius = 50; 
                newShape = { type: 'circle', x, y, rx: initialRadius, ry: initialRadius, color, rotation: 0 };
            } else if (type === 'rectangle') {
                const initialSize = 50; 
                newShape = { 
                    type: 'rectangle', x, y, rotation: 0, color, 
                    vertices: [
                        { x: -initialSize, y: -initialSize }, { x: initialSize, y: -initialSize },
                        { x: initialSize, y: initialSize }, { x: -initialSize, y: initialSize }
                    ]
                };
            } else if (type === 'triangle') {
                const initialBase = 100; 
                const initialHeight = 100; 
                newShape = { 
                    type: 'triangle', x, y, rotation: 0, color, 
                    vertices: [
                        { x: 0, y: -initialHeight / 2 },      
                        { x: initialBase / 2, y: initialHeight / 2 }, 
                        { x: -initialBase / 2, y: initialHeight / 2 }
                    ]
                };
            }

            shapes.unshift(newShape); 
            selectedShape = newShape;
            drawShapes();
        }

        function clearCanvas() {
            shapes = [];
            selectedShape = null;
            drawShapes();
        }
        
        function deleteSelectedShape() {
            if (!selectedShape) return;

            const index = shapes.indexOf(selectedShape);
            if (index > -1) {
                shapes.splice(index, 1);
            }
            selectedShape = null;
            drawShapes();
        }

        function regularizeShape() {
            if (!selectedShape) return;

            if (selectedShape.type === 'circle') {
                const maxRadius = Math.max(selectedShape.rx, selectedShape.ry);
                selectedShape.rx = maxRadius;
                selectedShape.ry = maxRadius;
                
            } else if (selectedShape.type === 'rectangle') {
                const bb = getBoundingBox(selectedShape.vertices);
                const avgSide = (bb.width + bb.height) / 2; 
                const halfSide = avgSide / 2;

                selectedShape.vertices = [
                    { x: -halfSide, y: -halfSide }, { x: halfSide, y: -halfSide },
                    { x: halfSide, y: halfSide }, { x: -halfSide, y: halfSide }
                ];
                
            } else if (selectedShape.type === 'triangle') {
                const side1 = getPolygonSideLength(selectedShape.vertices[0], selectedShape.vertices[1]);
                const side2 = getPolygonSideLength(selectedShape.vertices[1], selectedShape.vertices[2]);
                const side3 = getPolygonSideLength(selectedShape.vertices[2], selectedShape.vertices[0]);
                const sideLength = (side1 + side2 + side3) / 3; 

                const h = (Math.sqrt(3) / 2) * sideLength; 
                const halfSide = sideLength / 2;
                
                selectedShape.vertices = [
                    { x: 0, y: -h / 2 }, { x: halfSide, y: h / 2 }, 
                    { x: -halfSide, y: h / 2 }
                ];
            }

            drawShapes();
        }


        // -----------------------------------------------------
        // INTERACCIN (Manejadores de Mouse/Touch)
        // -----------------------------------------------------

        function isPointInShape(mx, my, shape) {
            const { x: localX, y: localY } = globalToLocal(mx, my, shape);

            if (shape.type === 'circle') {
                // Ecuaci贸n de elipse
                return (Math.pow(localX / shape.rx, 2) + Math.pow(localY / shape.ry, 2) <= 1);
            } 
            
            if (shape.type === 'rectangle' || shape.type === 'triangle') {
                // Uso de Ray Casting o simplificaci贸n por Bounding Box (BB) para pol铆gonos irregulares
                const bb = getBoundingBox(shape.vertices);
                return (localX >= bb.minX && localX <= bb.maxX && localY >= bb.minY && localY <= bb.maxY);
            }
            
            return false;
        }

        function getControlHit(mx, my, shape) {
            if (!shape) return { action: null, index: -1, cursor: 'default' };

            const controls = getShapeControls(shape);
            // La tolerancia de golpe debe ser constante en p铆xeles de pantalla
            const tolerance = 15 / scale; 
            
            // Check Rotation Control
            if (controls.rotate) {
                const distRotate = Math.sqrt(Math.pow(mx - controls.rotate.x, 2) + Math.pow(my - controls.rotate.y, 2));
                if (distRotate < controls.rotate.size + tolerance) {
                    return { action: 'rotate', index: -1, cursor: 'rotating' };
                }
            }

            // Check Resize Controls
            for (const ctrl of controls.resize) {
                const distResize = Math.sqrt(Math.pow(mx - ctrl.x, 2) + Math.pow(my - ctrl.y, 2));
                if (distResize < ctrl.size + tolerance) {
                    return { action: 'resize', index: ctrl.index, cursor: ctrl.cursorClass, axis: ctrl.axis };
                }
            }

            return { action: null, index: -1, cursor: 'default' };
        }

        function handlePolygonResize(shape, localMouseX, localMouseY, resizeControlIndex) {
            const vertices = shape.vertices;
            const vertexCount = vertices.length;
            
            if (resizeControlIndex < vertexCount) {
                // Resize corner (Move vertex)
                const vertexIndex = resizeControlIndex;
                vertices[vertexIndex].x = localMouseX;
                vertices[vertexIndex].y = localMouseY;
                
            } else {
                // Resize midpoint (Move edge - implemented as moving both vertices)
                const edgeIndex = resizeControlIndex - vertexCount;
                const v1Index = edgeIndex;
                const v2Index = (edgeIndex + 1) % vertexCount;
                
                const v1 = vertices[v1Index];
                const v2 = vertices[v2Index];
                const currentMidX = (v1.x + v2.x) / 2;
                const currentMidY = (v1.y + v2.y) / 2;
                
                const dx = localMouseX - currentMidX;
                const dy = localMouseY - currentMidY;
                
                v1.x += dx;
                v1.y += dy;
                v2.x += dx;
                v2.y += dy;
            }
        }
        
        function handleEllipseResize(shape, localMouseX, localMouseY, hit) {
            const axis = hit.axis;
            
            // El redimensionamiento de la elipse se hace relativo a su centro (0,0 local)
            if (axis === 'x') {
                shape.rx = Math.max(minRadius, Math.abs(localMouseX));
            } else if (axis === 'y') {
                shape.ry = Math.max(minRadius, Math.abs(localMouseY));
            }
        }

        let lastHit = null; // Almacena el objeto hit para conservar metadatos de redimensionamiento

        function handleMouseDown(e) {
            e.preventDefault(); 
            
            const worldPos = getWorldPos(e); 
            const screenPos = getScreenPos(e); 
            
            if (e.target !== canvas) {
                return;
            }

            // Reiniciar estados
            selectedShape = null;
            actionState = null;
            resizeControlIndex = -1;
            lastHit = null;

            // 1. Intentar golpear un control o una forma
            for (let i = 0; i < shapes.length; i++) {
                const shape = shapes[i];
                const hit = getControlHit(worldPos.x, worldPos.y, shape);

                if (hit.action) {
                    // Control de Redimensionamiento o Rotaci贸n
                    selectedShape = shape;
                    actionState = hit.action;
                    resizeControlIndex = hit.index; 
                    canvas.className = hit.cursor;
                    lastHit = hit; 
                    
                    // Mover la forma seleccionada al frente
                    shapes.splice(i, 1);
                    shapes.unshift(selectedShape);
                    break;
                } else if (isPointInShape(worldPos.x, worldPos.y, shape)) {
                    // Arrastre de Forma
                    selectedShape = shape;
                    actionState = 'drag';
                    dragOffset.x = worldPos.x - shape.x; 
                    dragOffset.y = worldPos.y - shape.y;
                    canvas.className = 'dragging';

                    // Mover la forma seleccionada al frente
                    shapes.splice(i, 1);
                    shapes.unshift(selectedShape);
                    break;
                }
            }
            
            // 2. Si no se seleccion贸 nada, iniciar PANNING (arrastrar la vista)
            if (!selectedShape) {
                actionState = 'pan';
                dragOffset.x = screenPos.x; 
                dragOffset.y = screenPos.y;
                canvas.className = 'panning';
            }
            
            drawShapes();
        }

        function handleMouseMove(e) {
            
            if (actionState !== null) {
                e.preventDefault(); 
            }
            
            const worldPos = getWorldPos(e); 
            const screenPos = getScreenPos(e); 

            // L贸gica de Panning (Movimiento de la vista por arrastre del canvas)
            if (actionState === 'pan') {
                const dx = screenPos.x - dragOffset.x;
                const dy = screenPos.y - dragOffset.y;

                offsetX += dx;
                offsetY += dy;

                applyPanLimits();

                dragOffset.x = screenPos.x;
                dragOffset.y = screenPos.y;

                drawShapes(); 
                return;
            }
            
            // L贸gica de Hover del Cursor (Solo para mouse)
            if (actionState === null && !e.touches) {
                let hoverAction = 'default';
                for(const shape of shapes) {
                    const hit = getControlHit(worldPos.x, worldPos.y, shape);
                    if (hit.action) {
                        hoverAction = hit.cursor;
                        break;
                    } else if (isPointInShape(worldPos.x, worldPos.y, shape)) {
                        hoverAction = 'dragging';
                        break;
                    }
                }
                canvas.className = hoverAction;
                return;
            }

            if (actionState === null) return;

            // L贸gica de Interacci贸n con la Forma
            if (!selectedShape) return; 

            if (actionState === 'rotate') {
                const dx = worldPos.x - selectedShape.x;
                const dy = worldPos.y - selectedShape.y;
                // Ajustamos el 谩ngulo de rotaci贸n usando el desplazamiento (225 grados) del control de rotaci贸n
                selectedShape.rotation = Math.atan2(dy, dx) - (225 * DEG_TO_RAD); 

            } else if (actionState === 'resize') {
                const { x: localMouseX, y: localMouseY } = globalToLocal(worldPos.x, worldPos.y, selectedShape);
                
                if (selectedShape.type === 'rectangle' || selectedShape.type === 'triangle') {
                    handlePolygonResize(selectedShape, localMouseX, localMouseY, resizeControlIndex);
                    
                } else if (selectedShape.type === 'circle') {
                    handleEllipseResize(selectedShape, localMouseX, localMouseY, lastHit);
                }

            } else if (actionState === 'drag') {
                selectedShape.x = worldPos.x - dragOffset.x;
                selectedShape.y = worldPos.y - dragOffset.y;
            }
            
            drawShapes();
        }

        function handleMouseUp(e) {
            actionState = null;
            resizeControlIndex = -1;
            lastHit = null;
            
            canvas.className = 'default';
            drawShapes(); 
        }

        // -----------------------------------------------------
        // LISTENERS
        // -----------------------------------------------------

        // Eventos de Mouse
        canvas.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        
        // Eventos T谩ctiles (Touch)
        canvas.addEventListener('touchstart', handleMouseDown); 
        document.addEventListener('touchmove', handleMouseMove, { passive: false });
        document.addEventListener('touchend', handleMouseUp);
        document.addEventListener('touchcancel', handleMouseUp);
        
        // Evento de Rueda para Zoom (escritorio)
        canvas.addEventListener('wheel', handleWheel, { passive: false });
        
    </script>
</body>
</html>
