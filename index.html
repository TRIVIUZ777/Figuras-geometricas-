<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor Geométrico Avanzado</title>
    <!-- Carga de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos base y cursores personalizados */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e2e8f0; /* Slate-200 */
            min-height: 100vh; /* Establece una altura mínima para el flex container del body */
            overflow-y: scroll; /* Cambio a 'scroll' para que la barra vertical esté siempre visible */
        }
        #geometricCanvas {
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            border: 4px solid #1e293b; 
            background-color: white;
            width: 100%;
            max-width: 900px;
            height: 500px; 
            touch-action: none; /* Crucial para evitar que el arrastre en el canvas haga scroll de la página */
            cursor: default;
        }
        /* Cursors for internal canvas interaction */
        .rotating { cursor: grab !important; }
        .dragging { cursor: grab !important; }
        .resizer-ns { cursor: ns-resize !important; } 
        .resizer-ew { cursor: ew-resize !important; } 
        .move-vertex { cursor: move !important; }
        .panning { cursor: all-scroll !important; } 

    </style>
</head>
<body class="p-4 flex flex-col items-center justify-start">

    <header class="text-center mb-8 w-full max-w-3xl">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-900 mb-2">
            📐 Editor de Figuras Avanzado
        </h1>
        <p class="text-gray-600 text-sm sm:text-base">
            Usa el arrastre del ratón o la rueda para navegar y hacer zoom en el lienzo.
            <span class="font-semibold text-sky-800">Escala: 10 píxeles = 1 cm.</span>
        </p>
    </header>

    <!-- Controles de Creación -->
    <div class="mb-6 flex flex-wrap justify-center gap-3 sm:gap-4 w-full max-w-3xl">
        <button onclick="addShape('circle')" class="flex-1 min-w-[120px] bg-sky-600 hover:bg-sky-700 text-white font-bold py-3 px-4 rounded-xl transition duration-300 shadow-md">
            Elipse
        </button>
        <button onclick="addShape('rectangle')" class="flex-1 min-w-[120px] bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-xl transition duration-300 shadow-md">
            Cuadrilátero
        </button>
        <button onclick="addShape('triangle')" class="flex-1 min-w-[120px] bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-xl transition duration-300 shadow-md">
            Triángulo Libre
        </button>
        <button onclick="clearCanvas()" class="w-full sm:w-auto bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-xl transition duration-300 shadow-md">
            Limpiar Todo
        </button>
    </div>
    
    <!-- Controles de Edición y Zoom -->
    <div class="mb-4 w-full max-w-[920px] flex justify-between items-start gap-4 flex-wrap">
        
        <!-- Controles de Edición de Figura Seleccionada -->
        <div class="flex items-start gap-4 flex-wrap" id="shapeControlsContainer">
            <!-- Botón de Regularización -->
            <div id="regularizeButtonContainer" class="hidden min-w-[150px] mt-2">
                <button id="regularizeButton" onclick="regularizeShape()" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-6 rounded-xl transition duration-300 shadow-lg text-sm sm:text-base">
                    Establecer Forma Regular
                </button>
            </div>
            
            <!-- Botón de Eliminación (NUEVO) -->
            <div id="deleteButtonContainer" class="hidden min-w-[150px] mt-2">
                <button id="deleteShapeButton" onclick="deleteSelectedShape()" class="bg-gray-800 hover:bg-gray-900 text-white font-bold py-3 px-6 rounded-xl transition duration-300 shadow-lg text-sm sm:text-base">
                    Eliminar Figura Seleccionada
                </button>
            </div>
        </div>

        <!-- Controles de Zoom -->
        <div class="flex items-center space-x-6 ml-auto mt-2 p-2 bg-white rounded-xl shadow-lg self-start">
            <!-- Botón de disminuir (-) -->
            <button onclick="zoom(1/1.1)" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold w-10 h-10 rounded-full transition duration-150 text-xl">-</button>
            <span id="zoomLevel" class="text-sm font-semibold text-gray-700 w-12 text-center">100%</span>
            <!-- Botón de aumentar (+) -->
            <button onclick="zoom(1.1)" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold w-10 h-10 rounded-full transition duration-150 text-xl">+</button>
        </div>
    </div>

    <!-- Área de dibujo -->
    <div class="w-full flex justify-center flex-col max-w-[900px] relative">
        <canvas id="geometricCanvas" class="rounded-xl flex-grow"></canvas>
    </div>

    <script>
        const canvas = document.getElementById("geometricCanvas");
        const ctx = canvas.getContext("2d");
        const regularizeButtonContainer = document.getElementById('regularizeButtonContainer');
        const deleteButtonContainer = document.getElementById('deleteButtonContainer'); 
        const zoomLevelSpan = document.getElementById('zoomLevel');
        
        // --- Configuración y Estado Global ---
        const DEG_TO_RAD = Math.PI / 180;
        const PIXELS_PER_CM = 10; 
        
        let shapes = []; 
        let selectedShape = null; 
        let actionState = null; 
        let dragOffset = { x: 0, y: 0 }; 
        let resizeControlIndex = -1; 
        
        const controlSize = 14; 
        const minRadius = 5;

        // --- Variables de Zoom y Panorámica ---
        let scale = 1.0;
        let offsetX = 0; 
        let offsetY = 0; 
        const maxScale = 3.0;
        const minScale = 0.2;
        
        // -----------------------------------------------------
        // UTILIDADES Y CÁLCULOS GEOMÉTRICOS
        // -----------------------------------------------------

        function getScreenPos(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX = e.clientX;
            let clientY = e.clientY;
            
            if (e.touches && e.touches.length) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }
        
        function getWorldPos(e) {
            const screenPos = getScreenPos(e);
            return {
                x: (screenPos.x - offsetX) / scale,
                y: (screenPos.y - offsetY) / scale
            };
        }

        function globalToLocal(gx, gy, shape) {
            const dx = gx - shape.x;
            const dy = gy - shape.y;
            const cosA = Math.cos(-shape.rotation);
            const sinA = Math.sin(-shape.rotation);
            return {
                x: dx * cosA - dy * sinA,
                y: dx * sinA + dy * cosA
            };
        }

        function localToGlobal(lx, ly, shape) {
            const cosA = Math.cos(shape.rotation);
            const sinA = Math.sin(shape.rotation);
            return {
                x: shape.x + lx * cosA - ly * sinA,
                y: shape.y + lx * sinA + ly * cosA
            };
        }
        
        function getBoundingBox(vertices) {
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            if (vertices.length === 0) return { minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0 };
            vertices.forEach(v => {
                minX = Math.min(minX, v.x);
                minY = Math.min(minY, v.y);
                maxX = Math.max(maxX, v.x);
                maxY = Math.max(maxY, v.y);
            });
            return { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY };
        }

        function getPolygonSideLength(v1, v2) {
            const dx = v2.x - v1.x;
            const dy = v2.y - v1.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // --- Funciones para Controles de Forma ---
        function getPolygonControls(shape) {
            const controls = { resize: [], rotate: null };
            const vertices = shape.vertices;
            const bb = getBoundingBox(vertices);
            const maxDimension = Math.max(bb.width, bb.height);
            const vertexCount = vertices.length;

            for (let i = 0; i < vertexCount; i++) {
                const globalPos = localToGlobal(vertices[i].x, vertices[i].y, shape);
                controls.resize.push({
                    x: globalPos.x, y: globalPos.y, index: i, type: 'corner',
                    cursorClass: 'move-vertex', size: controlSize / scale 
                });
            }

            for (let i = 0; i < vertexCount; i++) {
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % vertexCount]; 
                const midX = (v1.x + v2.x) / 2;
                const midY = (v1.y + v2.y) / 2;
                
                const globalPos = localToGlobal(midX, midY, shape);
                controls.resize.push({
                    x: globalPos.x, y: globalPos.y, index: i + vertexCount, type: 'midpoint',
                    cursorClass: 'move-vertex', size: controlSize / scale 
                });
            }
            return { controls, maxDimension };
        }

        function getEllipseControls(shape) {
            const controls = { resize: [], rotate: null };
            const halfW = shape.rx;
            const halfH = shape.ry;
            const maxDimension = Math.max(shape.rx, shape.ry) * 2;
            const margin = 10 / scale; 

            const ellipseControlsData = [
                { xLocal: 1, yLocal: 0, cursor: 'resizer-ew', axis: 'x', type: 'midpoint' }, 
                { xLocal: -1, yLocal: 0, cursor: 'resizer-ew', axis: 'x', type: 'midpoint' },
                { xLocal: 0, yLocal: 1, cursor: 'resizer-ns', axis: 'y', type: 'midpoint' }, 
                { xLocal: 0, yLocal: -1, cursor: 'resizer-ns', axis: 'y', type: 'midpoint' } 
            ];

            ellipseControlsData.forEach((data, index) => {
                let localX = halfW * data.xLocal;
                let localY = halfH * data.yLocal;
                
                localX += (data.xLocal !== 0 ? (data.xLocal > 0 ? margin : -margin) : 0);
                localY += (data.yLocal !== 0 ? (data.yLocal > 0 ? margin : -margin) : 0);

                const globalPos = localToGlobal(localX, localY, shape);
                controls.resize.push({
                    x: globalPos.x, y: globalPos.y, index: index, type: data.type,
                    cursorClass: data.cursor, size: controlSize / scale, axis: data.axis
                });
            });

            return { controls, maxDimension };
        }
        
        function getShapeControls(shape) {
            let controls = { resize: [], rotate: null };
            let maxDimension = 0;

            const isPolygon = shape.type === 'rectangle' || shape.type === 'triangle';

            if (isPolygon) {
                ({ controls, maxDimension } = getPolygonControls(shape));
            } else if (shape.type === 'circle') {
                ({ controls, maxDimension } = getEllipseControls(shape));
            }
            
            if (maxDimension > 0) {
                const rotationControlDistance = (maxDimension / 2) + (40 / scale); 
                const rotateAngle = shape.rotation + (225 * DEG_TO_RAD); 
                
                controls.rotate = {
                    x: shape.x + Math.cos(rotateAngle) * rotationControlDistance,
                    y: shape.y + Math.sin(rotateAngle) * rotationControlDistance,
                    size: controlSize / scale
                };
            }

            return controls;
        }


        // --- DIBUJO ---

        function getRandomColor() {
            const colors = ['#f59e0b', '#10b981', '#ef4444', '#3b82f6', '#8b5cf6'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function drawControl(ctrl) {
            ctx.save();
            ctx.beginPath();
            
            const strokeWidth = 2 / scale; 

            ctx.fillStyle = ctrl.type === 'corner' ? '#2563eb' : '#fbbf24'; 
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = strokeWidth;

            ctx.arc(ctrl.x, ctrl.y, ctrl.size, 0, 2 * Math.PI);
           
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        function drawPolygonSideLabels(shape) {
            if (shape !== selectedShape || (shape.type !== 'rectangle' && shape.type !== 'triangle')) {
                return;
            }

            const vertices = shape.vertices;
            const vertexCount = vertices.length;

            ctx.save();
            ctx.font = `${14 / scale}px Inter`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#1e3a8a'; 
            
            for (let i = 0; i < vertexCount; i++) {
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % vertexCount];
                
                const lengthPx = getPolygonSideLength(v1, v2);
                const lengthCm = (lengthPx / PIXELS_PER_CM).toFixed(2);
                
                const midX = (v1.x + v2.x) / 2;
                const midY = (v1.y + v2.y) / 2;
                
                let angle = Math.atan2(v2.y - v1.y, v2.x - v1.x);

                if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
                    angle += Math.PI;
                }
                
                const globalPos = localToGlobal(midX, midY, shape);

                ctx.save();
                ctx.translate(globalPos.x, globalPos.y);
                ctx.rotate(angle + shape.rotation); 

                const textYOffset = -15 / scale; 
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4 / scale;
                ctx.strokeText(`${lengthCm} cm`, 0, textYOffset); 

                ctx.fillText(`${lengthCm} cm`, 0, textYOffset);

                ctx.restore();
            }

            ctx.restore();
        }


        function drawShape(shape) {
            ctx.save(); 

            ctx.translate(shape.x, shape.y);
            ctx.rotate(shape.rotation);

            ctx.beginPath();
            ctx.fillStyle = shape.color;
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 2 / scale; 

            if (shape.type === 'circle') {
                ctx.ellipse(0, 0, shape.rx, shape.ry, 0, 0, 2 * Math.PI);

            } else if (shape.type === 'rectangle' || shape.type === 'triangle') {
                const vertices = shape.vertices;
                if (vertices.length > 0) {
                    ctx.moveTo(vertices[0].x, vertices[0].y); 
                    for (let i = 1; i < vertices.length; i++) {
                        ctx.lineTo(vertices[i].x, vertices[i].y);
                    }
                    ctx.closePath();
                }
            }

            ctx.fill();
            ctx.stroke();

            ctx.restore(); 

            if (shape === selectedShape) {
                const controls = getShapeControls(shape);
                
                controls.resize.forEach(drawControl);

                const rotateCtrl = controls.rotate;
                if (rotateCtrl) {
                    ctx.beginPath();
                    ctx.arc(rotateCtrl.x, rotateCtrl.y, rotateCtrl.size, 0, 2 * Math.PI);
                    ctx.fillStyle = '#16a34a'; 
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2 / scale;
                    ctx.fill();
                    ctx.stroke();
                }

                if (shape.type === 'rectangle' || shape.type === 'triangle') {
                     drawPolygonSideLabels(shape); 
                }
               
                if (shape.type === 'circle') {
                    const dimensions = [
                        { label: 'Rx', value: (shape.rx / PIXELS_PER_CM).toFixed(2) },
                        { label: 'Ry', value: (shape.ry / PIXELS_PER_CM).toFixed(2) }
                    ];

                    ctx.save();
                    ctx.fillStyle = '#1e3a8a'; 
                    ctx.font = `${14 / scale}px Inter`; 
                    ctx.textAlign = 'center';
                    
                    const textY = shape.y + Math.max(shape.ry, shape.rx) + (35 / scale);

                    dimensions.forEach((dim, index) => {
                        ctx.fillText(
                            `${dim.label}: ${dim.value} cm`, 
                            shape.x, 
                            textY + (index * 20 / scale) 
                        );
                    });
                    ctx.restore();
                }
            }
        }

        function drawShapes() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(offsetX, offsetY); 
            ctx.scale(scale, scale);         

            for(let i = shapes.length - 1; i >= 0; i--) {
                drawShape(shapes[i]);
            }

            ctx.restore(); 
            
            updateControlButtonsVisibility(); 
            updateZoomLevelDisplay();
        }

        // -----------------------------------------------------
        // GESTIÓN DE VISTA (ZOOM & PAN)
        // -----------------------------------------------------

        function updateZoomLevelDisplay() {
            zoomLevelSpan.textContent = `${Math.round(scale * 100)}%`;
        }

        function zoom(factor, mouseX = canvas.width / 2, mouseY = canvas.height / 2) {
            const oldScale = scale;
            const newScale = Math.min(maxScale, Math.max(minScale, scale * factor));
            
            if (newScale !== oldScale) {
                const scaleRatio = newScale / oldScale;
                
                offsetX = mouseX - scaleRatio * (mouseX - offsetX);
                offsetY = mouseY - scaleRatio * (mouseY - offsetY);

                scale = newScale;
                drawShapes();
            }
        }
        
        function handleWheel(e) {
            e.preventDefault(); 
            const screenPos = getScreenPos(e); 
            const factor = e.deltaY < 0 ? 1.1 : 1 / 1.1; 
            
            zoom(factor, screenPos.x, screenPos.y);
        }

        // -----------------------------------------------------
        // INICIALIZACIÓN Y LÓGICA DE FORMAS
        // -----------------------------------------------------

        function resizeCanvas() {
            const containerWidth = canvas.parentElement.clientWidth;
            canvas.width = Math.min(containerWidth, 900);
            canvas.height = 500; 
            drawShapes();
        }
        window.addEventListener('resize', resizeCanvas);
        window.onload = resizeCanvas; 

        function updateControlButtonsVisibility() {
            const isShapeSelected = selectedShape !== null;
            const isRegularizable = isShapeSelected && (selectedShape.type === 'circle' || selectedShape.type === 'rectangle' || selectedShape.type === 'triangle');
            
            if (isRegularizable) {
                regularizeButtonContainer.classList.remove('hidden');
            } else {
                regularizeButtonContainer.classList.add('hidden');
            }
            
            // Show/Hide Delete Button
            if (isShapeSelected) {
                deleteButtonContainer.classList.remove('hidden');
            } else {
                deleteButtonContainer.classList.add('hidden');
            }
        }

        function addShape(type) {
            const color = getRandomColor();
            // Center in the current view
            const x = (canvas.width / 2 - offsetX) / scale; 
            const y = (canvas.height / 2 - offsetY) / scale;
            let newShape;

            if (type === 'circle') {
                const initialRadius = 50; 
                newShape = { type: 'circle', x, y, rx: initialRadius, ry: initialRadius, color, rotation: 0 };
            } else if (type === 'rectangle') {
                const initialSize = 50; 
                newShape = { 
                    type: 'rectangle', x, y, rotation: 0, color, 
                    vertices: [
                        { x: -initialSize, y: -initialSize }, { x: initialSize, y: -initialSize },
                        { x: initialSize, y: initialSize }, { x: -initialSize, y: initialSize }
                    ]
                };
            } else if (type === 'triangle') {
                const initialBase = 100; 
                const initialHeight = 100; 
                newShape = { 
                    type: 'triangle', x, y, rotation: 0, color, 
                    vertices: [
                        { x: 0, y: -initialHeight / 2 },      
                        { x: initialBase / 2, y: initialHeight / 2 }, 
                        { x: -initialBase / 2, y: initialHeight / 2 }
                    ]
                };
            }

            shapes.unshift(newShape); 
            selectedShape = newShape;
            drawShapes();
        }

        function clearCanvas() {
            shapes = [];
            selectedShape = null;
            drawShapes();
        }
        
        // Función para eliminar la figura seleccionada
        function deleteSelectedShape() {
            if (!selectedShape) return;

            const index = shapes.indexOf(selectedShape);
            if (index > -1) {
                shapes.splice(index, 1);
            }
            selectedShape = null;
            drawShapes();
        }

        function regularizeShape() {
            if (!selectedShape) return;

            if (selectedShape.type === 'circle') {
                const maxRadius = Math.max(selectedShape.rx, selectedShape.ry);
                selectedShape.rx = maxRadius;
                selectedShape.ry = maxRadius;
                
            } else if (selectedShape.type === 'rectangle') {
                const bb = getBoundingBox(selectedShape.vertices);
                const avgSide = (bb.width + bb.height) / 2; 
                const halfSide = avgSide / 2;

                selectedShape.vertices = [
                    { x: -halfSide, y: -halfSide }, { x: halfSide, y: -halfSide },
                    { x: halfSide, y: halfSide }, { x: -halfSide, y: halfSide }
                ];
                
            } else if (selectedShape.type === 'triangle') {
                const side1 = getPolygonSideLength(selectedShape.vertices[0], selectedShape.vertices[1]);
                const side2 = getPolygonSideLength(selectedShape.vertices[1], selectedShape.vertices[2]);
                const side3 = getPolygonSideLength(selectedShape.vertices[2], selectedShape.vertices[0]);
                const sideLength = (side1 + side2 + side3) / 3; 

                const h = (Math.sqrt(3) / 2) * sideLength; 
                const halfSide = sideLength / 2;
                
                selectedShape.vertices = [
                    { x: 0, y: -h / 2 }, { x: halfSide, y: h / 2 }, 
                    { x: -halfSide, y: h / 2 }
                ];
            }

            drawShapes();
        }


        // -----------------------------------------------------
        // INTERACCIÓN (Manejadores de Mouse/Touch)
        // -----------------------------------------------------

        function isPointInShape(mx, my, shape) {
            const { x: localX, y: localY } = globalToLocal(mx, my, shape);

            if (shape.type === 'circle') {
                return (Math.pow(localX / shape.rx, 2) + Math.pow(localY / shape.ry, 2) <= 1);
            } 
            
            if (shape.type === 'rectangle' || shape.type === 'triangle') {
                const bb = getBoundingBox(shape.vertices);
                const minX = bb.minX;
                const maxX = bb.maxX;
                const minY = bb.minY;
                const maxY = bb.maxY;
                
                return (localX >= minX && localX <= maxX && localY >= minY && localY <= maxY);
            }
            
            return false;
        }

        function getControlHit(mx, my, shape) {
            if (!shape) return { action: null, index: -1, cursor: 'default' };

            const controls = getShapeControls(shape);
            const tolerance = 15 / scale; 
            
            if (controls.rotate) {
                const distRotate = Math.sqrt(Math.pow(mx - controls.rotate.x, 2) + Math.pow(my - controls.rotate.y, 2));
                if (distRotate < controls.rotate.size + tolerance) {
                    return { action: 'rotate', index: -1, cursor: 'rotating' };
                }
            }

            for (const ctrl of controls.resize) {
                const distResize = Math.sqrt(Math.pow(mx - ctrl.x, 2) + Math.pow(my - ctrl.y, 2));
                if (distResize < ctrl.size + tolerance) {
                    return { action: 'resize', index: ctrl.index, cursor: ctrl.cursorClass, axis: ctrl.axis };
                }
            }

            return { action: null, index: -1, cursor: 'default' };
        }

        function handlePolygonResize(shape, localMouseX, localMouseY, resizeControlIndex) {
            const vertices = shape.vertices;
            const vertexCount = vertices.length;
            
            if (resizeControlIndex < vertexCount) {
                const vertexIndex = resizeControlIndex;
                vertices[vertexIndex].x = localMouseX;
                vertices[vertexIndex].y = localMouseY;
                
            } else {
                const edgeIndex = resizeControlIndex - vertexCount;
                const v1Index = edgeIndex;
                const v2Index = (edgeIndex + 1) % vertexCount;
                
                const v1 = vertices[v1Index];
                const v2 = vertices[v2Index];
                const currentMidX = (v1.x + v2.x) / 2;
                const currentMidY = (v1.y + v2.y) / 2;
                
                const dx = localMouseX - currentMidX;
                const dy = localMouseY - currentMidY;
                
                v1.x += dx;
                v1.y += dy;
                v2.x += dx;
                v2.y += dy;
            }
        }
        
        function handleEllipseResize(shape, localMouseX, localMouseY, hit) {
            const axis = hit.axis;
            
            if (axis === 'x') {
                shape.rx = Math.max(minRadius, Math.abs(localMouseX));
            } else if (axis === 'y') {
                shape.ry = Math.max(minRadius, Math.abs(localMouseY));
            }
        }

        let lastHit = null; 

        function handleMouseDown(e) {
            e.preventDefault(); 
            
            const worldPos = getWorldPos(e); 
            const screenPos = getScreenPos(e); 
            
            // Si el click no es en el canvas, ignorar
            if (e.target !== canvas) {
                return;
            }

            selectedShape = null;
            actionState = null;
            resizeControlIndex = -1;
            lastHit = null;

            // 1. Intentar golpear un control o una forma
            for (let i = 0; i < shapes.length; i++) {
                const shape = shapes[i];
                const hit = getControlHit(worldPos.x, worldPos.y, shape);

                if (hit.action) {
                    selectedShape = shape;
                    actionState = hit.action;
                    resizeControlIndex = hit.index; 
                    canvas.className = hit.cursor;
                    lastHit = hit; 
                    
                    shapes.splice(i, 1);
                    shapes.unshift(selectedShape);
                    break;
                } else if (isPointInShape(worldPos.x, worldPos.y, shape)) {
                    selectedShape = shape;
                    actionState = 'drag';
                    dragOffset.x = worldPos.x - shape.x; 
                    dragOffset.y = worldPos.y - shape.y;
                    canvas.className = 'dragging';

                    shapes.splice(i, 1);
                    shapes.unshift(selectedShape);
                    break;
                }
            }
            
            // 2. Si no se seleccionó nada, iniciar PANNING (arrastrar la vista)
            if (!selectedShape) {
                actionState = 'pan';
                dragOffset.x = screenPos.x; 
                dragOffset.y = screenPos.y;
                canvas.className = 'panning';
            }
            
            drawShapes();
        }

        function handleMouseMove(e) {
            e.preventDefault(); 
            
            const worldPos = getWorldPos(e); 
            const screenPos = getScreenPos(e); 

            // Lógica de Panning (Movimiento de la vista por arrastre del canvas)
            if (actionState === 'pan') {
                const dx = screenPos.x - dragOffset.x;
                const dy = screenPos.y - dragOffset.y;

                offsetX += dx;
                offsetY += dy;

                dragOffset.x = screenPos.x;
                dragOffset.y = screenPos.y;

                drawShapes(); 
                return;
            }
            
            // Lógica de Hover del Cursor (Solo para mouse)
            // e.touches es undefined o false si es evento de mouse
            if (actionState === null && !e.touches) {
                let hoverAction = 'default';
                for(const shape of shapes) {
                    const hit = getControlHit(worldPos.x, worldPos.y, shape);
                    if (hit.action) {
                        hoverAction = hit.cursor;
                        break;
                    } else if (isPointInShape(worldPos.x, worldPos.y, shape)) {
                        hoverAction = 'dragging';
                        break;
                    }
                }
                canvas.className = hoverAction;
                return;
            }

            // Lógica de Interacción con la Forma
            if (!selectedShape) return; 

            if (actionState === 'rotate') {
                const dx = worldPos.x - selectedShape.x;
                const dy = worldPos.y - selectedShape.y;
                selectedShape.rotation = Math.atan2(dy, dx) - (225 * DEG_TO_RAD); 

            } else if (actionState === 'resize') {
                const { x: localMouseX, y: localMouseY } = globalToLocal(worldPos.x, worldPos.y, selectedShape);
                
                if (selectedShape.type === 'rectangle' || selectedShape.type === 'triangle') {
                    handlePolygonResize(selectedShape, localMouseX, localMouseY, resizeControlIndex);
                    
                } else if (selectedShape.type === 'circle') {
                    handleEllipseResize(selectedShape, localMouseX, localMouseY, lastHit);
                }

            } else if (actionState === 'drag') {
                selectedShape.x = worldPos.x - dragOffset.x;
                selectedShape.y = worldPos.y - dragOffset.y;
            }
            
            drawShapes();
        }

        function handleMouseUp(e) {
            actionState = null;
            resizeControlIndex = -1;
            lastHit = null;
            
            canvas.className = 'default';
            drawShapes(); 
        }

        // -----------------------------------------------------
        // LISTENERS
        // -----------------------------------------------------

        // Eventos de Mouse
        canvas.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        
        // Eventos Táctiles (Touch)
        canvas.addEventListener('touchstart', handleMouseDown); 
        // Se deja passive: false para que e.preventDefault() funcione correctamente
        document.addEventListener('touchmove', handleMouseMove, { passive: false });
        document.addEventListener('touchend', handleMouseUp);
        document.addEventListener('touchcancel', handleMouseUp);
        
        // Evento de Rueda para Zoom (escritorio)
        canvas.addEventListener('wheel', handleWheel, { passive: false });
        
    </script>
</body>
</html>

