<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dibujos Geom√©tricos Interactivos y Arrastrables</title>
    <!-- Carga de Tailwind CSS para un dise√±o moderno -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Definici√≥n de la fuente y estilos base */
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            background-color: #f7fafc; 
        }
        /* Estilo para el canvas */
        #miCanvas {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border: 4px solid #4a5568; 
            cursor: grab; 
        }
        .resizing {
            cursor: nwse-resize !important;
        }
        .rotating {
            cursor: move !important; 
        }
        .dragging {
            cursor: grabbing !important;
        }
    </style>
</head>
<body class="p-6 flex flex-col items-center justify-start">

    <header class="text-center mb-8">
        <h1 class="text-4xl font-extrabold text-gray-800 mb-2">
            üìê Editor Geom√©trico Persistente
        </h1>
        <p class="text-gray-600">
            Crea figuras, arr√°stralas, redimensiona y r√≥talas. (Datos guardados en la nube)
        </p>
        <p class="text-sm text-gray-500 mt-1">
            ID de Usuario: <span id="userIdDisplay" class="font-mono text-xs bg-gray-200 p-1 rounded">Cargando...</span>
        </p>
    </header>

    <!-- Controles de Creaci√≥n y Limpieza -->
    <div class="mb-6 flex flex-wrap justify-center gap-4">
        <button onclick="addShape('circle')" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 transform hover:scale-105 shadow-md">
            A√±adir C√≠rculo
        </button>
        <button onclick="addShape('square')" class="bg-green-500 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 transform hover:scale-105 shadow-md">
            A√±adir Cuadrado
        </button>
        <button onclick="addShape('triangle')" class="bg-pink-500 hover:bg-pink-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 transform hover:scale-105 shadow-md">
            A√±adir Tri√°ngulo
        </button>
        <button onclick="clearCanvas()" class="bg-red-500 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 transform hover:scale-105 shadow-md">
            Limpiar Todo
        </button>
    </div>
    
    <!-- Panel de control de medidas (visible solo cuando hay una figura seleccionada) -->
    <div id="controlsPanel" class="mb-6 p-4 bg-white border border-gray-300 rounded-lg shadow-lg w-full max-w-lg hidden">
        <h3 class="font-bold text-gray-700 mb-2 flex items-center justify-between">
            Modificar Figura Seleccionada
            <span id="shapeName" class="text-sm font-semibold text-indigo-600"></span>
        </h3>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <!-- Input de Rotaci√≥n (siempre visible) -->
            <div class="flex flex-col">
                <label for="input-rotation" class="text-sm font-medium text-gray-600">Rotaci√≥n (¬∞)</label>
                <input type="number" id="input-rotation" value="0" step="1"
                       class="mt-1 p-2 border border-gray-300 rounded-md focus:border-indigo-500 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
            </div>
            <!-- Los campos de medida se inyectan aqu√≠ din√°micamente -->
            <div id="measureInputs" class="col-span-2 grid grid-cols-2 gap-4"></div>
        </div>
    </div>
    
    <!-- √Årea de dibujo -->
    <canvas id="miCanvas" width="500" height="400" class="rounded-xl bg-white"></canvas>

    <!-- Bot√≥n y Contenedor para la integraci√≥n de Gemini -->
    <div class="mt-6 flex flex-wrap justify-center gap-4 w-full max-w-lg">
        <button id="generateDescBtn" onclick="generateSceneDescription()" class="bg-purple-600 hover:bg-purple-800 text-white font-bold py-3 px-6 rounded-lg transition duration-300 transform hover:scale-105 shadow-md flex items-center justify-center w-full">
            ‚ú® Generar Descripci√≥n de Escena (IA)
        </button>
    </div>

    <!-- Contenedor para el resultado del LLM -->
    <div id="llmOutput" class="mt-4 p-4 bg-yellow-100 border border-yellow-300 text-yellow-800 rounded-lg shadow-lg w-full max-w-lg hidden">
        <h3 class="font-bold mb-2 text-gray-700">Resultado de Gemini:</h3>
        <p id="llmText"></p>
        <div id="llmLoading" class="text-sm font-semibold mt-2 text-center text-purple-600 hidden">Cargando la inspiraci√≥n...</div>
    </div>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // CONFIGURACI√ìN DE FIREBASE (Variables globales proporcionadas por el entorno)
        let db, auth, userId = null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // --- INICIALIZACI√ìN DE CANVAS Y VARIABLES ---
        const canvas = document.getElementById("miCanvas");
        const ctx = canvas.getContext("2d");

        const PIXELS_PER_CM = 20;
        const RAD_TO_DEG = 180 / Math.PI;
        const DEG_TO_RAD = Math.PI / 180;

        let shapes = []; 

        let isDragging = false;
        let isResizing = false;
        let isRotating = false;
        let selectedShape = null; 
        let dragOffsetX = 0;      
        let dragOffsetY = 0;      

        // Elementos de UI
        const controlsPanel = document.getElementById('controlsPanel');
        const measureInputs = document.getElementById('measureInputs');
        const shapeNameSpan = document.getElementById('shapeName');
        const inputRotation = document.getElementById('input-rotation');
        const llmOutputDiv = document.getElementById('llmOutput');
        const llmTextP = document.getElementById('llmText');
        const llmLoadingDiv = document.getElementById('llmLoading');
        const generateDescBtn = document.getElementById('generateDescBtn');
        const userIdDisplay = document.getElementById('userIdDisplay');

        // Variables para la API de Gemini
        const apiKey = ""; 
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
        
        // Inicializar listeners de rotaci√≥n de UI (asumiendo que es una funci√≥n global para el HTML)
        inputRotation.addEventListener('change', handleRotationInput);


        // -----------------------------------------------------
        // FIREBASE PERSISTENCIA
        // -----------------------------------------------------

        function getDocRef() {
            if (!db || !userId) {
                console.error("Firestore no est√° inicializado o el userId no est√° disponible.");
                return null;
            }
            // Ruta privada: /artifacts/{appId}/users/{userId}/geometry_shapes/current_scene
            return doc(db, 'artifacts', appId, 'users', userId, 'geometry_shapes', 'current_scene');
        }

        async function saveShapes() {
            const ref = getDocRef();
            if (!ref) return;
            try {
                // Guardar la lista completa de figuras
                await setDoc(ref, { shapes: shapes }, { merge: false });
            } catch(e) { 
                console.error("Error saving shapes to Firestore:", e); 
            }
        }

        function startListening() {
            const ref = getDocRef();
            if (!ref) return;
            
            // onSnapshot escucha los cambios en tiempo real, incluso si otro usuario modifica (aunque este es privado)
            onSnapshot(ref, (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const data = docSnapshot.data();
                    if (data && Array.isArray(data.shapes)) {
                        shapes = data.shapes.map(s => ({
                            ...s,
                            // Asegurar que la rotaci√≥n exista y sea un n√∫mero al cargar
                            rotation: s.rotation || 0 
                        })); 
                        selectedShape = null; // Deseleccionar al recargar
                        drawShapes();
                        console.log("Shapes loaded from Firestore.");
                    }
                } else {
                    // Si el documento no existe, crear uno con un array vac√≠o para empezar
                    shapes = [];
                    saveShapes();
                    drawShapes();
                    console.log("No existing document found. Initializing new scene.");
                }
            }, (error) => {
                console.error("Error listening to shapes:", error);
            });
        }

        async function initFirebase() {
            if (!firebaseConfig) {
                console.error("Firebase config no est√° disponible.");
                userIdDisplay.textContent = "Error de Config.";
                return;
            }

            try {
                const app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                userId = auth.currentUser?.uid || crypto.randomUUID();
                userIdDisplay.textContent = userId;

                startListening();
            } catch (error) {
                console.error("Error de inicializaci√≥n de Firebase:", error);
                userIdDisplay.textContent = "Error Auth.";
            }
        }

        // -----------------------------------------------------
        // L√ìGICA DEL EDITOR GEOM√âTRICO (Igual que antes, pero llama a saveShapes)
        // -----------------------------------------------------

        function pxToCm(px) { return (px / PIXELS_PER_CM).toFixed(1); }
        function cmToPx(cm) { return parseFloat(cm) * PIXELS_PER_CM; }

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) { color += letters[Math.floor(Math.random() * 16)]; }
            return color;
        }

        function handleRotationInput(e) {
            const newDegrees = parseFloat(e.target.value);
            if (selectedShape && !isNaN(newDegrees)) {
                selectedShape.rotation = newDegrees * DEG_TO_RAD;
                drawShapes();
                saveShapes(); // Guardar despu√©s de la rotaci√≥n manual
            }
        }

        function updateControlsPanel() {
            measureInputs.innerHTML = ''; 
            controlsPanel.classList.add('hidden');

            if (!selectedShape) {
                inputRotation.value = 0;
                return;
            }

            shapeNameSpan.textContent = selectedShape.type.toUpperCase();
            controlsPanel.classList.remove('hidden');

            let currentDegrees = selectedShape.rotation * RAD_TO_DEG;
            currentDegrees = currentDegrees % 360;
            if (currentDegrees > 180) currentDegrees -= 360;
            if (currentDegrees < -180) currentDegrees += 360;
            inputRotation.value = currentDegrees.toFixed(0);

            const createInput = (label, propName, value) => {
                const cmValue = pxToCm(value);
                const inputId = `input-${propName}`;
                
                const div = document.createElement('div');
                div.className = 'flex flex-col';
                div.innerHTML = `
                    <label for="${inputId}" class="text-sm font-medium text-gray-600">${label} (cm)</label>
                    <input type="number" id="${inputId}" value="${cmValue}" step="0.1" min="0.5"
                           class="mt-1 p-2 border border-gray-300 rounded-md focus:border-indigo-500 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                `;
                
                const input = div.querySelector('input');
                input.addEventListener('change', (e) => {
                    const newCm = parseFloat(e.target.value);
                    if (newCm >= 0.5) { 
                        selectedShape[propName] = cmToPx(newCm);
                        drawShapes();
                        saveShapes(); // Guardar despu√©s de redimensionar
                    } else {
                        e.target.value = pxToCm(selectedShape[propName]); 
                    }
                });
                
                measureInputs.appendChild(div);
            };

            if (selectedShape.type === 'circle') {
                createInput('Radio', 'radius', selectedShape.radius);
            } else if (selectedShape.type === 'square') {
                createInput('Lado', 'size', selectedShape.size);
            } else if (selectedShape.type === 'triangle') {
                createInput('Base', 'base', selectedShape.base);
                createInput('Altura', 'height', selectedShape.height);
            }
        }


        function drawShape(shape) {
            ctx.save(); 
            ctx.translate(shape.x, shape.y);
            ctx.rotate(shape.rotation);

            ctx.beginPath();
            ctx.fillStyle = shape.color;
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 2;

            if (shape.type === 'circle') {
                ctx.arc(0, 0, shape.radius, 0, 2 * Math.PI);
            } else if (shape.type === 'square') {
                ctx.rect(-shape.size / 2, -shape.size / 2, shape.size, shape.size);
            } else if (shape.type === 'triangle') {
                const h = shape.height;
                const b = shape.base;
                const topY = -(h * 2 / 3); 
                
                ctx.moveTo(0, topY);
                ctx.lineTo(b / 2, topY + h);
                ctx.lineTo(-b / 2, topY + h);
                ctx.closePath();
            }

            ctx.fill();
            ctx.stroke();
            ctx.restore(); 

            if (shape === selectedShape) {
                const majorAxis = shape.type === 'circle' ? shape.radius : 
                                  shape.type === 'square' ? shape.size * 0.707 : 
                                  Math.sqrt((shape.base / 2) ** 2 + shape.height ** 2) / 1.5; 
                
                const centerToControl = majorAxis + 20; 

                // Control de Redimensionamiento (Punto Azul - 45 grados de rotaci√≥n)
                const resizeAngle = shape.rotation + 45 * DEG_TO_RAD; 
                const resizeX = shape.x + Math.cos(resizeAngle) * centerToControl;
                const resizeY = shape.y + Math.sin(resizeAngle) * centerToControl;

                ctx.beginPath();
                ctx.arc(resizeX, resizeY, 6, 0, 2 * Math.PI);
                ctx.fillStyle = isResizing ? '#CC0000' : '#0099CC'; 
                ctx.fill();
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Control de Rotaci√≥n (Punto Verde - 135 grados de rotaci√≥n)
                const rotateAngle = shape.rotation + 135 * DEG_TO_RAD; 
                const rotateX = shape.x + Math.cos(rotateAngle) * centerToControl;
                const rotateY = shape.y + Math.sin(rotateAngle) * centerToControl;
                
                ctx.beginPath();
                ctx.arc(rotateX, rotateY, 6, 0, 2 * Math.PI);
                ctx.fillStyle = isRotating ? '#007700' : '#00CC00'; 
                ctx.fill();
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
        }

        function drawShapes() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            shapes.forEach(drawShape);
            updateControlsPanel(); 
        }

        function clearCanvas() {
            shapes = [];
            selectedShape = null;
            drawShapes();
            saveShapes(); // Guardar despu√©s de limpiar
            llmOutputDiv.classList.add('hidden');
        }

        function addShape(type) {
            const color = getRandomColor();
            const x = Math.floor(Math.random() * (canvas.width - 100)) + 50;
            const y = Math.floor(Math.random() * (canvas.height - 100)) + 50;

            let newShape;

            if (type === 'circle') {
                newShape = { type: 'circle', x, y, radius: 40, color, rotation: 0 };
            } else if (type === 'square') {
                newShape = { type: 'square', x, y, size: 80, color, rotation: 0 };
            } else if (type === 'triangle') {
                newShape = { type: 'triangle', x, y, base: 80, height: 80, color, rotation: 0 };
            }

            shapes.unshift(newShape); 
            selectedShape = newShape;
            drawShapes();
            saveShapes(); // Guardar despu√©s de a√±adir
        }

        function isPointInShape(mx, my, shape) {
            const dx = mx - shape.x;
            const dy = my - shape.y;

            const cosA = Math.cos(-shape.rotation);
            const sinA = Math.sin(-shape.rotation);
            const rotatedX = dx * cosA - dy * sinA;
            const rotatedY = dx * sinA + dy * cosA;

            if (shape.type === 'circle') {
                return (rotatedX * rotatedX + rotatedY * rotatedY < shape.radius * shape.radius);
            } else if (shape.type === 'square') {
                const halfSize = shape.size / 2;
                return (rotatedX > -halfSize && rotatedX < halfSize &&
                        rotatedY > -halfSize && rotatedY < halfSize);
            } else if (shape.type === 'triangle') {
                const halfBase = shape.base / 2;
                const h = shape.height;
                const topY = -(h * 2 / 3); 
                const bottomY = topY + h;

                return (rotatedX > -halfBase && rotatedX < halfBase &&
                        rotatedY > topY && rotatedY < bottomY);
            }
            return false;
        }

        function isPointInControl(mx, my, shape, controlType) {
            const majorAxis = shape.type === 'circle' ? shape.radius : 
                              shape.type === 'square' ? shape.size * 0.707 : 
                              Math.sqrt((shape.base / 2) ** 2 + shape.height ** 2) / 1.5; 
            
            const centerToControl = majorAxis + 20;

            let angle;
            if (controlType === 'resize') {
                angle = shape.rotation + 45 * DEG_TO_RAD;
            } else if (controlType === 'rotate') {
                angle = shape.rotation + 135 * DEG_TO_RAD;
            } else {
                return false;
            }

            const ctrlX = shape.x + Math.cos(angle) * centerToControl;
            const ctrlY = shape.y + Math.sin(angle) * centerToControl;
            
            const dist = Math.sqrt(Math.pow(mx - ctrlX, 2) + Math.pow(my - ctrlY, 2));
            return dist < 10;
        }

        function getAngle(shape, pos) {
            const dx = pos.x - shape.x;
            const dy = pos.y - shape.y;
            return Math.atan2(dy, dx
